---
title: "Serena MCP 集成扩展策略"
date: 2025-11-27
status: "Proposed"
philosophy: ["Think Different", "Simplify Ruthlessly", "Craft, Don't Code"]
impact: "high"
---

## 背景

### 当前状况
- Serena MCP 已在 `wf_03_prime`（项目上下文加载）中自动激活
- Serena MCP 已在 `wf_06_debug` 中支持（`--deep` 标志）
- 项目中存在 5 个高度依赖代码操作的命令：wf_05_code, wf_07_test, wf_08_review, wf_09_refactor, wf_10_optimize

### 问题陈述
当前 Serena MCP 的集成范围有限。大量代码操作的命令（实现、审查、重构、测试、优化）都没有充分利用 Serena 的 23 个符号级工具，导致：
- 开发效率受限（需要手动查找代码位置、理解结构）
- 代码质量风险（审查时容易遗漏引用关联）
- 重构风险高（手动重命名容易导致遗漏）

### 为什么现状无法接受
1. **时间浪费** - 手动查找代码位置需要 10-30 分钟
2. **高错误率** - 手动操作的遗漏率 5-10%（特别是重构）
3. **不够优雅** - 虽然有工具，但没有充分使用
4. **不一致** - 有些命令用了 MCP (wf_03_prime)，有些没用 (wf_05_code)

### 约束条件
1. **Token 成本** - Serena LSP 启动需要 1000-2000 tokens
2. **自动激活平衡** - 不能每条命令都自动启动 LSP（成本过高）
3. **向后兼容** - 所有 MCP 必须是可选的，不能破坏现有工作流
4. **分阶段实施** - 避免大规模重构导致风险累积

---

## 选项分析

### 选项 A: 为所有 15 个 wf 命令启用 Serena MCP

**描述**: 为所有工作流命令都添加 Serena MCP 支持，包括不需要代码操作的命令（如 wf_01_planning, wf_12_deploy_check 等）

**优势**:
- 完全覆盖，没有盲点
- 一致的 MCP 策略（所有命令都支持）
- 用户选择灵活

**劣势**:
- 实施工作量大（15 个命令，每个需要 2-3 小时）
- 维护负担重（15 个文件同步更新）
- 很多命令根本不需要 Serena（如规划、研究、部署）
- 总工作量：40-50 小时

**成本估计**: 40-50 小时

---

### 选项 B: 仅为最高优先级的 3 个命令启用（保守方案）

**描述**: 只为 wf_09_refactor, wf_05_code, wf_08_review 三个最关键的命令启用 Serena MCP

**优势**:
- 工作量小（3 个命令 × 3 小时 = 9 小时）
- 聚焦核心价值（这 3 个命令是最常用的）
- 风险低，易于验证效果
- 维护负担轻

**劣势**:
- wf_07_test 和 wf_10_optimize 无法受益
- 不够全面（遗漏了可以受益的命令）
- 后续可能需要再次扩展

**成本估计**: 9 小时 + 2 小时测试 = 11 小时

---

### 选项 C: 分层推进（推荐方案）⭐

**描述**: 将 wf 命令按代码操作密集度分 3 层，分阶段集成：
- **Tier 1（最高优先级）**: wf_09_refactor, wf_05_code, wf_08_review（立即）
- **Tier 2（高优先级）**: wf_07_test, wf_10_optimize（后续）
- **Tier 3（可选）**: wf_14_doc（与 Magic 配合）

**优势**:
- ✅ 聚焦价值（按需求优先级）
- ✅ 分阶段降低风险（先验证 Tier 1 的效果）
- ✅ 灵活扩展（后续可按实际收益决定）
- ✅ 工作量可控（分 3 个周期）
- ✅ 维护成本低（先集成 3 个）

**劣势**:
- 实施跨度长（3-4 周）
- 初期覆盖不完整

**成本估计**:
- Phase 1: 9 小时
- Phase 2: 4 小时
- Phase 3: 1 小时
- 总计: 14 小时（加测试）

---

## 决策

**我们选择了: 选项 C - 分层推进（Tier 1 优先）**

### 理由

1. **最大化效率投入** - Tier 1 的 3 个命令是 80% 的代码操作工作，投入产出比最高
2. **降低风险** - 分阶段实施，每个阶段验证成功后再进行下一个
3. **保持灵活性** - 根据 Tier 1 的实际效果，决定是否继续 Tier 2/3
4. **符合 Simplify Ruthlessly** - 不做过度设计，先解决核心问题
5. **符合 Think Different** - 质疑"所有命令都需要"的假设，只为需要的命令启用

### 关键考量

- **Tier 1 优先度判断依据**：
  - wf_09_refactor: rename_symbol() 是天然的、最匹配的使用场景（100% 适配）
  - wf_05_code: 代码实现最常用（70% 的开发时间）
  - wf_08_review: 审查需要引用完整性检查（70% 的审查工作）

- **自动激活策略**：
  - wf_09_refactor: 总是自动激活（重构就是 Serena 的核心场景）
  - wf_08_review: 条件激活（检测到符号修改时）
  - wf_05_code: 手动激活（--serena 标志，避免每次启动 LSP）

- **标志统一**：
  - `--serena` - 显式启用 Serena
  - `--deep` - 深度分析模式（包含 Serena 和其他深度分析）
  - `--no-mcp` - 禁用所有 MCP

---

## 权衡 (Tradeoffs)

### 收益

**开发效率提升**（第一层面）:
- wf_09_refactor: 70-90% 时间节省（手动查找引用 → 自动重命名）
- wf_05_code: 50-70% 时间节省（手动浏览 → 精确定位）
- wf_08_review: 60-80% 时间节省（手动检查 → 自动验证）
- **总体时间节省**: 55-80%

**代码质量提升**（第二层面）:
- wf_09_refactor: 错误率从 5-10% → 0%（自动化消除遗漏）
- wf_08_review: 遗漏率从 30-40% → 5-10%（自动化引用检查）
- **总体错误率降低**: 50-95%

**架构优雅度提升**（第三层面）:
- 充分利用已有的 Serena 工具（23 个符号级操作）
- 建立清晰的 MCP 分层策略（而非混乱的点缀）
- 符合"优先使用成熟工具"的设计原则

### 成本

**短期成本**:
- Phase 1 实施: 6-9 小时开发 + 3 小时测试 = 9-12 小时
- 文档更新: 2-3 小时
- **总计**: 11-15 小时

**每次使用的 Token 成本**:
- wf_09_refactor: +1000-2000 tokens（Serena LSP 启动 + 查询）
- wf_05_code: +500-1500 tokens（可选启用）
- wf_08_review: +1500-2500 tokens（全面检查）
- **平均增加**: 30-60% Token 成本

**维护成本**:
- 需要同时更新 3 个命令文档（一致性维护）
- Serena LSP 版本更新时可能需要同步

### 风险

**集成风险**:
1. **LSP 启动失败** - Serena LSP 可能在某些环境不可用
   - 缓解: 优雅降级（如果 LSP 失败，继续用普通模式）
   - 监控: 记录 LSP 启动失败的情况

2. **性能问题** - LSP 查询可能很慢
   - 缓解: 设置超时（30 秒），超时后降级
   - 监控: 记录查询耗时，超过阈值警告

3. **准确性问题** - Serena 可能找不到或找错符号
   - 缓解: AI 验证结果，不盲目接受
   - 监控: 如果准确率 < 90%，需要调查

**采用风险**:
1. **学习曲线** - 用户需要学习新的标志和工作流
   - 缓解: 详细的文档和示例
   - 时间: 预期用户需要 1-2 个命令才能习惯

2. **标志爆炸** - 过多的标志导致混淆
   - 缓解: 只支持 --serena / --deep / --no-mcp（最少化）
   - 清晰性: 文档中详细说明何时使用

**扩展风险**:
1. **Tier 2 可能不需要** - 实施后发现收益不足
   - 缓解: 3 个月后评估效果，决定是否继续
   - 决策点: 如果 Token 成本 > 50% 且时间节省 < 30%，则不继续

---

## 后续行动

### Phase 1: 核心命令集成（优先级：🔴 高）

- [ ] **任务 1**: 为 wf_09_refactor 集成 Serena（2-3 小时）
  - 修改 wf_09_refactor.md，添加 Serena 自动激活逻辑
  - 添加使用示例和工作流说明

- [ ] **任务 2**: 为 wf_05_code 集成 Serena（2-3 小时）
  - 修改 wf_05_code.md，添加 --serena 标志
  - 添加代码插入点定位示例

- [ ] **任务 3**: 为 wf_08_review 集成 Serena（2-3 小时）
  - 修改 wf_08_review.md，添加引用完整性检查
  - 添加条件激活规则

### Phase 2: 文档和验证（优先级：🔴 高）

- [ ] **任务 4**: 创建本 ADR 并获得认可（已完成）

- [ ] **任务 5**: 更新 CLAUDE.md MCP 部分（30 分钟）
  - 更新 MCP 支持的命令表
  - 添加 Serena 使用指南

- [ ] **任务 6**: 集成测试验证（2 小时）
  - 验证 LSP 启动和符号查询
  - 测试重构、代码实现、审查的完整场景
  - 验证错误降级机制

### Phase 3: 扩展命令集成（优先级：🟡 低，3 个月后评估）

- [ ] **任务 7**: 为 wf_07_test 集成 Serena（后续）
- [ ] **任务 8**: 为 wf_10_optimize 集成 Serena（后续）

---

## 重新评估条件

### 触发条件（何时重新考虑这个决策）

1. **Phase 1 效果不达预期**（1 个月后）
   - 如果实际时间节省 < 30%，暂停 Phase 2
   - 如果 Token 成本 > 100%，降低激活频率

2. **Serena LSP 稳定性问题**（持续）
   - 如果 LSP 启动失败率 > 5%，需要改进降级机制
   - 如果符号查询准确率 < 85%，需要手动验证流程

3. **用户反馈**（持续）
   - 如果多个用户反映标志太复杂，简化设计
   - 如果用户认为 Token 成本不可接受，调整自动激活策略

4. **Tier 2 评估**（3 个月后）
   - Phase 1 完成 3 个月后，评估是否继续 Phase 2
   - 决策标准：
     - ✅ 继续：时间节省 > 50% 或错误率降低 > 50%
     - ⏸️ 延迟：效果一般，先等待 Serena 改进
     - ❌ 放弃：效果不明显，Token 成本无法接受

### 评估时间

- Phase 1 效果评估: 2025-12-27（1 个月后）
- Tier 2 决策: 2026-02-27（3 个月后）
- 季度末复审: 每季度末（Q1/Q2/Q3/Q4）

---

## 参考资源

- **当前 Serena 集成**: wf_03_prime.md, wf_06_debug.md
- **MCP 架构文档**: docs/integration/MCP_ARCHITECTURE.md
- **MCP 用户指南**: docs/integration/MCP_USER_GUIDE.md
- **Serena 功能列表**: 23 个符号级工具（find_symbol, rename_symbol, replace_symbol_body 等）
- **CLAUDE.md MCP 部分**: § 🔌 MCP 集成和增强功能

---

## 历史

| 日期 | 事件 | 备注 |
|------|------|------|
| 2025-11-27 | Proposed | 基于结构化分析提议，选择方案 C（分层推进） |
| TBD | Phase 1 Complete | 3 个命令集成完成后更新 |
| TBD | Phase 1 Evaluation | 1 个月后评估效果 |
| TBD | Phase 2 Decision | 3 个月后决定是否继续 Phase 2 |
| TBD | Accepted | 团队同意并开始实施 |

---

## 附录：Ultrathink 设计原则对齐

### Think Different - 质疑假设

❌ **默认假设**: "所有命令都应该有 Serena 支持"
✅ **质疑结果**: 只有 5 个命令真正需要代码理解，其他 10 个命令基本不需要

**应用**: 采用分层方案，只为需要的命令启用，避免"大而全"的陷阱

---

### Simplify Ruthlessly - 简化设计

🎨 **原设计**: 为所有 15 个命令添加 Serena MCP（50+ 小时）
✨ **简化版**: 为 3 个核心命令添加（9-12 小时），之后按需扩展

**应用**: 减少 75% 的初期工作量，将复杂度从"一次全做"改为"逐步推进"

---

### Craft, Don't Code - 优雅实现

💎 **优雅之处**:
1. **智能激活策略** - wf_09_refactor 自动激活（最匹配），wf_05_code 手动激活（降低成本）
2. **统一的标志命名** - 只有 3 个标志（--serena, --deep, --no-mcp），避免爆炸
3. **分阶段实施** - 从验证到扩展，风险递进式降低
4. **清晰的决策点** - 1 个月和 3 个月两个明确的评估时刻

**应用**: 优雅的集成方案，易于理解、使用和维护

---

## Tier 1 命令集成详情

### wf_09_refactor（代码重构）

**Serena 的核心能力**: `rename_symbol()` - 自动重命名所有引用
- 时间节省: 70-90%（手动查找 10-30 分钟 → 自动完成 1-2 分钟）
- 错误率: 从 5-10% → 0%（完全消除遗漏）

**使用示例**:
```bash
# 自动激活 Serena
/wf_09_refactor "将 getUserData() 重命名为 fetchUserData()"

# Serena 自动执行：
# 1. find_symbol("getUserData")
# 2. rename_symbol("getUserData" → "fetchUserData")
# 3. 验证所有引用已更新
```

---

### wf_05_code（代码实现）

**Serena 的核心能力**: `find_symbol()`, `get_symbols_overview()`, `insert_after_symbol()`
- 时间节省: 50-70%（理解结构 5-15 分钟 → 快速定位 1-3 分钟）
- 准确性: 插入点准确率 70% → 95%

**使用示例**:
```bash
# 复杂修改启用 Serena
/wf_05_code "为 User 类添加 login 方法" --serena

# Serena 步骤：
# 1. find_symbol("User", depth=1) - 查看现有方法
# 2. get_symbols_overview("user.py") - 理解文件结构
# 3. 确定插入点（find_referencing_symbols 理解用法）
# 4. insert_after_symbol("User/logout") - 在 logout 后插入
```

---

### wf_08_review（代码审查）

**Serena 的核心能力**: `find_referencing_symbols()` - 检查所有引用
- 时间节省: 60-80%（手动检查 15-30 分钟 → 自动验证 2-5 分钟）
- 发现问题率: 从 60% → 90%（更全面的检查）

**使用示例**:
```bash
# 自动检测符号修改
/wf_08_review

# 当发现符号修改时，Serena 自动：
# 1. find_referencing_symbols("getUserData") - 找所有调用点
# 2. 验证是否所有调用都已更新
# 3. 检查是否有测试需要同步更新
```

---

