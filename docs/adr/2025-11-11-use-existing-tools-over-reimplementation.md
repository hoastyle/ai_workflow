---
title: "命令文档必须明确指示使用项目工具而非重新实现"
date: 2025-11-11
status: "Accepted"
philosophy: ["Simplify Ruthlessly", "Think Different", "Craft, Don't Code"]
impact: "high"
---

## 背景

在执行 `/wf_14_doc --auto` 命令时，AI 创建了临时脚本（`/tmp/generate_frontmatter.sh`）来生成 Frontmatter，而没有使用项目中已有的工具 `scripts/frontmatter_utils.py`。

**问题**:
- 命令文档（`wf_14_doc.md`）包含伪代码示例，但没有明确指示使用已有工具
- AI 看到伪代码后，认为需要自己实现功能
- 导致重复实现、Token 浪费、代码质量不一致

**当前情况**:
- ✅ 项目有完整的工具脚本 `scripts/frontmatter_utils.py` (534 行)
- ✅ 工具提供完整功能：验证、生成、关系图
- ❌ 命令文档没有明确指示使用工具
- ❌ 文档中的伪代码 `from generate_frontmatter import ...` 不是实际路径
- ❌ AI 每次执行都重新实现功能

**为什么现状无法接受**:
- Token 消耗：重新实现 ~8000 tokens vs 调用工具 ~200 tokens（浪费 97.5%）
- 代码质量：临时脚本可能缺少错误处理、测试不充分
- 维护成本：工具脚本更新后，AI 生成的临时脚本不会同步
- 架构一致性：违反"重用优于重写"原则

**约束条件**:
- 命令文档是 AI 执行的唯一指令来源
- AI 无法"猜测"项目中存在哪些工具
- 需要明确、可执行的命令示例而非伪代码

## 选项分析

### 选项 A: 在命令文档中添加工具清单和明确指令

**描述**: 在命令文档开头添加 "🛠️ 可用工具" 部分，列出所有项目工具、路径和使用方式。将伪代码替换为实际的 Bash 命令。

**优势**:
- ✅ AI 执行前就知道有哪些工具可用
- ✅ 明确的执行规则（必须使用、绝不重新实现）
- ✅ 实际命令示例（可直接复制执行）
- ✅ Token 效率对比展示（97.5% 节省）
- ✅ 实施成本低（只需修改文档）

**劣势**:
- 需要为每个使用工具的命令添加清单
- 文档长度略微增加（~50 行）

**成本估计**: 30 分钟（修改 1 个命令文档）

### 选项 B: 在 CLAUDE.md 中添加全局工具清单

**描述**: 在 `CLAUDE.md` 中维护项目所有工具的清单，命令文档引用该清单。

**优势**:
- 工具清单集中管理
- 所有命令共享同一份清单

**劣势**:
- ❌ AI 可能不会主动关联 CLAUDE.md 和命令文档
- ❌ 命令文档中仍需明确指示使用哪个工具
- ❌ 增加维护复杂度（两个地方都要更新）

**成本估计**: 1 小时（创建清单 + 修改所有命令文档）

### 选项 C: 创建工具发现机制（AI 自动扫描 scripts/）

**描述**: 在命令执行前，让 AI 自动扫描 `scripts/` 目录，发现可用工具。

**优势**:
- 自动发现，无需手动维护清单
- 新增工具自动可用

**劣势**:
- ❌ 扫描增加执行开销
- ❌ AI 仍需判断哪个工具适合当前任务
- ❌ 无法提供明确的使用指导
- ❌ 实现复杂度高

**成本估计**: 2 小时（设计 + 实现 + 测试）

## 决策

**我们选择了: 选项 A - 在命令文档中添加工具清单和明确指令**

**理由**:
1. **即时可见性**: AI 读取命令文档时立即看到可用工具，无需额外查找
2. **明确性**: 实际命令示例比伪代码更清晰，AI 知道该执行什么
3. **执行规则**: 明确的 ✅ 必须 / ❌ 禁止 规则，防止误操作
4. **低成本**: 只需修改文档，无需改代码或架构
5. **可扩展**: 模式可复用到其他使用工具的命令

**关键考量**:
- 命令文档是 AI 的"执行手册"，必须足够明确
- 伪代码用于"理解概念"，实际命令用于"执行操作"
- Token 效率提升 97.5% 是显著收益

## 权衡 (Tradeoffs)

### 收益
- **Token 效率**: 每次执行节省 ~7800 tokens（97.5%）
- **代码质量**: 使用经过测试的工具脚本，而非临时实现
- **维护性**: 工具脚本统一维护，所有命令自动受益
- **开发体验**: AI 执行更快、更可靠
- **架构一致性**: 符合"重用优于重写"原则

### 成本
- **文档长度**: 每个命令文档增加 ~50 行（工具清单 + 使用说明）
- **维护负担**: 新增工具时需要更新相关命令文档
- **初次实施**: 需要审查所有命令文档，识别哪些应添加工具清单

### 风险
- **风险**: 文档和工具不同步（工具路径变化、参数变化）
- **缓解**: 在工具脚本中添加版本检查，定期运行 `/wf_13_doc_maintain` 验证
- **监控指标**:
  - AI 是否仍创建临时脚本（应为 0）
  - Token 消耗趋势（应下降）
  - 工具脚本调用成功率（应 >95%）

## 后续行动

- [x] 修改 `wf_14_doc.md` 添加工具清单
- [x] 替换伪代码为实际命令示例
- [x] 添加明确的执行规则（必须/禁止）
- [ ] 审查其他命令文档（`wf_05_code.md`, `wf_11_commit.md` 等）
- [ ] 创建命令文档编写规范（避免类似问题）
- [ ] 更新 KNOWLEDGE.md 记录这个决策
- [ ] 在下次执行中验证 AI 是否正确调用工具

## 重新评估条件

什么情况下应该重新考虑这个决策？

**触发条件**:
- AI 仍然创建临时脚本而非调用工具（说明指令不够明确）
- 工具清单维护成本过高（工具频繁变更）
- 发现更好的工具发现机制（如 AI 能力升级）
- 命令文档过于冗长影响理解

**评估时间**: 1 个月后（2025-12-11）或完成 10 次相关命令执行后

## 参考资源

- [修改后的 wf_14_doc.md](../../wf_14_doc.md)
- [项目工具脚本](../../scripts/frontmatter_utils.py)
- [Frontmatter 规范文档](../reference/FRONTMATTER.md)
- [相关问题讨论](#背景)

## 历史

| 日期 | 事件 | 备注 |
|------|------|------|
| 2025-11-11 | Proposed | 发现问题，架构咨询分析 |
| 2025-11-11 | Accepted | 立即执行修复，创建 ADR |
| 2025-11-11 | Implemented | 完成 wf_14_doc.md 修改 |

## 相关 Ultrathink 原则

### Simplify Ruthlessly
- **问题**: 重复实现功能增加复杂性
- **解决**: 重用已有工具，保持简洁

### Think Different
- **问题**: AI 没有质疑"是否需要重新实现"
- **解决**: 明确指令让 AI 优先考虑重用

### Craft, Don't Code
- **问题**: 临时脚本是"编码"而非"精心设计"
- **解决**: 使用经过设计的工具脚本，优雅协作
