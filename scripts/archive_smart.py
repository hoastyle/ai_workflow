#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
æ™ºèƒ½æ–‡æ¡£å­˜æ¡£è„šæœ¬ (Smart Document Archive)

ç‰ˆæœ¬: v1.0
åˆ›å»ºæ—¥æœŸ: 2025-12-21
ç”¨é€”: æ ¹æ®æ–‡æ¡£ç±»å‹å’Œé…ç½®ï¼Œè‡ªåŠ¨æ‰§è¡Œæ™ºèƒ½å­˜æ¡£æ“ä½œ

æ”¯æŒçš„å‘½ä»¤:
  python scripts/archive_smart.py --file TASK.md
  python scripts/archive_smart.py --file TASK.md --dry-run
  python scripts/archive_smart.py --file TASK.md --auto
  python scripts/archive_smart.py --batch
  python scripts/archive_smart.py --batch --dry-run

è®¾è®¡ç‰¹ç‚¹:
  - ç­–ç•¥æ¨¡å¼: æ¯ç§æ–‡æ¡£ç±»å‹æœ‰ç‹¬ç«‹çš„å­˜æ¡£ç­–ç•¥
  - åŸå­æ“ä½œ: å¤‡ä»½-æ“ä½œ-éªŒè¯-æäº¤çš„å››æ­¥æµç¨‹
  - è‡ªåŠ¨å›æ»š: å¤±è´¥æ—¶è‡ªåŠ¨æ¢å¤åˆ°å¤‡ä»½çŠ¶æ€
  - è¯¦ç»†æŠ¥å‘Š: ç”Ÿæˆæ¸…æ™°çš„æ“ä½œæ—¥å¿—å’Œç»Ÿè®¡ä¿¡æ¯
"""

import argparse
import os
import re
import shutil
import sys
from abc import ABC, abstractmethod
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from collections import defaultdict

try:
    import yaml
except ImportError:
    print("âŒ é”™è¯¯: éœ€è¦å®‰è£… PyYAML")
    print("   è¿è¡Œ: pip install PyYAML")
    sys.exit(1)


# ============================================
# æ•°æ®æ¨¡å‹
# ============================================

@dataclass
class ArchiveResult:
    """å­˜æ¡£æ“ä½œç»“æœ"""
    success: bool
    file_path: str
    original_lines: int
    archived_lines: int
    kept_lines: int
    archive_file: Optional[str] = None
    error_message: Optional[str] = None


class ArchiveStrategy(ABC):
    """å­˜æ¡£ç­–ç•¥çš„æŠ½è±¡åŸºç±»"""

    def __init__(self, config: Dict, file_path: str):
        self.config = config
        self.file_path = file_path
        self.doc_name = Path(file_path).name

    @abstractmethod
    def identify_content_structure(self, content: str) -> Dict:
        """è¯†åˆ«æ–‡æ¡£ç»“æ„ï¼Œè¿”å›å¯åˆ†ç¦»çš„å†…å®¹å—"""
        pass

    @abstractmethod
    def determine_archive_boundary(self, structure: Dict) -> Tuple[int, str]:
        """ç¡®å®šå­˜æ¡£åˆ†ç•Œçº¿ï¼Œè¿”å› (åˆ†ç•Œè¡Œå·, åˆ†ç•Œè¯´æ˜)"""
        pass

    @abstractmethod
    def generate_archive_filename(self) -> str:
        """ç”Ÿæˆå­˜æ¡£æ–‡ä»¶å"""
        pass

    def execute_archive(self, dry_run: bool = False) -> ArchiveResult:
        """æ‰§è¡Œå­˜æ¡£æ“ä½œï¼ˆç­–ç•¥æ¨¡æ¿æ–¹æ³•ï¼‰"""
        try:
            # Step 1: è¯»å–åŸå§‹æ–‡ä»¶
            if not os.path.exists(self.file_path):
                return ArchiveResult(
                    success=False,
                    file_path=self.file_path,
                    original_lines=0,
                    archived_lines=0,
                    kept_lines=0,
                    error_message=f"æ–‡ä»¶ä¸å­˜åœ¨: {self.file_path}"
                )

            with open(self.file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()

            lines = original_content.split('\n')
            original_lines = len(lines)

            # Step 2: è¯†åˆ«ç»“æ„
            structure = self.identify_content_structure(original_content)
            if not structure:
                return ArchiveResult(
                    success=False,
                    file_path=self.file_path,
                    original_lines=original_lines,
                    archived_lines=0,
                    kept_lines=original_lines,
                    error_message="æ— æ³•è¯†åˆ«æ–‡æ¡£ç»“æ„"
                )

            # Step 3: ç¡®å®šåˆ†ç•Œçº¿
            boundary_line, boundary_reason = self.determine_archive_boundary(structure)
            if boundary_line <= 0 or boundary_line >= original_lines:
                return ArchiveResult(
                    success=False,
                    file_path=self.file_path,
                    original_lines=original_lines,
                    archived_lines=0,
                    kept_lines=original_lines,
                    error_message=f"æ— æ•ˆçš„åˆ†ç•Œçº¿: {boundary_line}"
                )

            # Step 4: åˆ†ç¦»å†…å®¹
            kept_content = '\n'.join(lines[:boundary_line])
            archived_content = '\n'.join(lines[boundary_line:])

            kept_lines = len(kept_content.split('\n'))
            archived_lines = len(archived_content.split('\n'))

            # Step 5: ç”Ÿæˆå­˜æ¡£æ–‡ä»¶åå’Œè·¯å¾„
            archive_filename = self.generate_archive_filename()
            archive_dir = self.config.get('archive_path', 'docs/archives')
            archive_path = os.path.join(archive_dir, archive_filename)

            # Step 6: åˆ›å»ºå¤‡ä»½
            backup_path = f"{self.file_path}.backup.{datetime.now().strftime('%Y%m%d%H%M%S')}"
            shutil.copy2(self.file_path, backup_path)

            try:
                if not dry_run:
                    # Step 7a: åˆ›å»ºå­˜æ¡£ç›®å½•
                    os.makedirs(archive_dir, exist_ok=True)

                    # Step 7b: å†™å…¥ä¿ç•™å†…å®¹
                    with open(self.file_path, 'w', encoding='utf-8') as f:
                        f.write(kept_content)

                    # Step 7c: å†™å…¥å­˜æ¡£æ–‡ä»¶
                    with open(archive_path, 'w', encoding='utf-8') as f:
                        f.write(archived_content)

                    # Step 7d: åˆ é™¤å¤‡ä»½
                    os.remove(backup_path)

                return ArchiveResult(
                    success=True,
                    file_path=self.file_path,
                    original_lines=original_lines,
                    archived_lines=archived_lines,
                    kept_lines=kept_lines,
                    archive_file=archive_path
                )

            except Exception as e:
                # å›æ»š: æ¢å¤å¤‡ä»½
                shutil.copy2(backup_path, self.file_path)
                os.remove(backup_path)
                return ArchiveResult(
                    success=False,
                    file_path=self.file_path,
                    original_lines=original_lines,
                    archived_lines=0,
                    kept_lines=original_lines,
                    error_message=f"å­˜æ¡£å¤±è´¥ï¼Œå·²å›æ»š: {str(e)}"
                )

        except Exception as e:
            return ArchiveResult(
                success=False,
                file_path=self.file_path,
                original_lines=0,
                archived_lines=0,
                kept_lines=0,
                error_message=f"æ„å¤–é”™è¯¯: {str(e)}"
            )


# ============================================
# å…·ä½“çš„å­˜æ¡£ç­–ç•¥å®ç°
# ============================================

class PhaseBasedArchive(ArchiveStrategy):
    """åŸºäºé˜¶æ®µçš„å­˜æ¡£ç­–ç•¥ (ç”¨äº TASK.md)

    è®¾è®¡ç›®æ ‡:
    1. å¤šé˜¶æ®µ: ä¿ç•™æœ€æ–°é˜¶æ®µï¼Œå½’æ¡£å†å²é˜¶æ®µ
    2. å•é˜¶æ®µ: æ‹’ç»å­˜æ¡£ï¼ˆä¿ç•™æ‰€æœ‰å†…å®¹ï¼ŒåŒ…æ‹¬å…ƒæ•°æ®å’Œå¾…å¼€å§‹ä»»åŠ¡ï¼‰
    3. å…³é”®åŸåˆ™: å§‹ç»ˆä¿æŠ¤æ–‡æ¡£å…ƒæ•°æ®ã€é˜¶æ®µæ¦‚è¿°ã€è¿›åº¦ç»Ÿè®¡
    """

    def identify_content_structure(self, content: str) -> Dict:
        """è¯†åˆ« TASK.md çš„å®Œæ•´ç»“æ„"""
        structure = {}
        lines = content.split('\n')

        # 1. æ‰¾åˆ°å…ƒæ•°æ®ç»“æŸä½ç½®ï¼ˆç¬¬ä¸€ä¸ª ## æ ‡é¢˜ï¼‰
        metadata_end = self._find_metadata_end(lines)

        # 2. è¯†åˆ«æ‰€æœ‰é˜¶æ®µ
        current_phase = None
        phase_start_line = 0
        phase_num = 0

        for i, line in enumerate(lines):
            match = re.match(r'^##\s+ğŸš€?\s*Phase\s+(\d+)', line)
            if match:
                if current_phase is not None:
                    structure[current_phase] = {
                        'start_line': phase_start_line,
                        'end_line': i,
                        'name': current_phase,
                        'number': phase_num
                    }
                phase_num = int(match.group(1))
                current_phase = f"Phase {phase_num}"
                phase_start_line = i

        # æ·»åŠ æœ€åä¸€ä¸ª Phase
        if current_phase is not None:
            structure[current_phase] = {
                'start_line': phase_start_line,
                'end_line': len(lines),
                'name': current_phase,
                'number': phase_num
            }

        # 3. å­˜å‚¨å…ƒæ•°æ®ä¿¡æ¯
        structure['_meta'] = {
            'metadata_end': metadata_end,
            'total_lines': len(lines)
        }

        return structure

    def _find_metadata_end(self, lines: List[str]) -> int:
        """æ‰¾åˆ°å…ƒæ•°æ®çš„ç»“æŸä½ç½®ï¼ˆç¬¬ä¸€ä¸ª ## æ ‡é¢˜å¤„ï¼‰"""
        for i, line in enumerate(lines):
            if re.match(r'^##\s+ğŸš€?', line):  # åŒ¹é…ä»»ä½• ## æ ‡é¢˜ï¼ˆé˜¶æ®µæˆ–å…¶ä»–ï¼‰
                return i
        return len(lines)

    def determine_archive_boundary(self, structure: Dict) -> Tuple[int, str]:
        """ç¡®å®šå­˜æ¡£åˆ†ç•Œçº¿ï¼ˆå…³é”®é€»è¾‘ï¼‰

        æ ¸å¿ƒåŸåˆ™:
        1. å• Phase: æ‹’ç»å­˜æ¡£ (return -1) - ä¿ç•™æ‰€æœ‰å†…å®¹
        2. å¤š Phase: åœ¨æœ€æ–° Phase å¤„è®¾åˆ†ç•Œ - ä¿ç•™æœ€æ–°ï¼Œå½’æ¡£å†å²
        """
        if not structure or '_meta' not in structure:
            return -1, "æ— æ³•è¯†åˆ«ç»“æ„"

        meta = structure['_meta']
        phases = {k: v for k, v in structure.items() if k != '_meta'}

        # æŒ‰é˜¶æ®µå·æ’åºï¼ˆä»æ–°åˆ°æ—§ï¼‰
        phases_list = sorted(
            phases.items(),
            key=lambda x: x[1]['number'],
            reverse=True
        )

        if not phases_list:
            return -1, "æ²¡æœ‰æ‰¾åˆ°é˜¶æ®µ"

        # ç­–ç•¥ A: å•é˜¶æ®µæ–‡æ¡£ - æ‹’ç»å­˜æ¡£
        if len(phases_list) == 1:
            return -1, (
                "å•é˜¶æ®µæ–‡æ¡£æš‚ä¸å­˜æ¡£ã€‚åŸå› : \n"
                "  â€¢ æ–‡æ¡£åªæœ‰ 1 ä¸ªé˜¶æ®µï¼Œæ— å†å²å†…å®¹å¯å­˜æ¡£\n"
                "  â€¢ ç­‰å¾…å‡ºç°å¤šä¸ªé˜¶æ®µåå†è¿›è¡Œå­˜æ¡£"
            )

        # ç­–ç•¥ B: å¤šé˜¶æ®µæ–‡æ¡£ - åœ¨æœ€æ–°é˜¶æ®µå¤„è®¾åˆ†ç•Œ
        if len(phases_list) >= 2:
            latest_phase = phases_list[0][1]
            boundary = latest_phase['start_line']
            archived_phases_count = len(phases_list) - 1
            return boundary, (
                f"ä¿ç•™æœ€æ–°é˜¶æ®µ {latest_phase['name']}ï¼Œ"
                f"å½’æ¡£å†å² {archived_phases_count} ä¸ªé˜¶æ®µ"
            )

        return -1, "æ— æ³•ç¡®å®šåˆ†ç•Œçº¿"

    def generate_archive_filename(self) -> str:
        """ç”Ÿæˆå­˜æ¡£æ–‡ä»¶å: TASK-archive-YYYY-QX-phases-X-Y.md"""
        today = datetime.now()
        quarter = (today.month - 1) // 3 + 1
        year = today.year

        # è¯»å–æ–‡ä»¶ä»¥ç¡®å®šåŒ…å«çš„é˜¶æ®µ
        with open(self.file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        phases = re.findall(r'Phase\s+(\d+)', content)
        if phases:
            min_phase = min(int(p) for p in phases)
            max_phase = max(int(p) for p in phases)
            return f"TASK-archive-{year}-Q{quarter}-phases-{min_phase}-{max_phase}.md"
        else:
            return f"TASK-archive-{year}-Q{quarter}.md"


class VersionBasedArchive(ArchiveStrategy):
    """åŸºäºç‰ˆæœ¬çš„å­˜æ¡£ç­–ç•¥ (ç”¨äº PLANNING.md)"""

    def identify_content_structure(self, content: str) -> Dict:
        """è¯†åˆ« PLANNING.md çš„ç‰ˆæœ¬ç»“æ„"""
        versions = {}

        # å°è¯•ä»æ–‡ä»¶å¤´éƒ¨è·å–ç‰ˆæœ¬ä¿¡æ¯
        match = re.search(r'\*\*ç‰ˆæœ¬\*\*:\s*v([\d.]+)', content)
        if match:
            current_version = f"v{match.group(1)}"
            versions['current'] = {
                'version': current_version,
                'position': 'header'
            }

        return versions

    def determine_archive_boundary(self, structure: Dict) -> Tuple[int, str]:
        """ç¡®å®šå­˜æ¡£åˆ†ç•Œçº¿ï¼šä¿ç•™å½“å‰ç‰ˆæœ¬ï¼Œå½’æ¡£å†å²ç‰ˆæœ¬"""
        # å¯¹äº PLANNING.mdï¼Œå¯ä»¥æŒ‰æœ€åæ›´æ–°æ—¶é—´åˆ†ç¦»
        lines = []
        with open(self.file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # æŸ¥æ‰¾æœ€åçš„ä¸»è¦å†…å®¹å—ï¼ˆé€šè¿‡æœ€åçš„ ## æ ‡é¢˜ï¼‰
        last_major_section = 0
        for i, line in enumerate(lines):
            if re.match(r'^##\s+', line):
                last_major_section = i

        # ä¿ç•™åˆ°æœ€åä¸€ä¸ªä¸»è¦ç« èŠ‚ä¹‹åçº¦ 10 è¡Œ
        boundary = min(last_major_section + 10, len(lines) - 1)

        if boundary > 0 and boundary < len(lines):
            return boundary, "ä¿ç•™å½“å‰ç‰ˆæœ¬å†…å®¹ï¼Œå½’æ¡£å†å²ç‰ˆæœ¬"
        else:
            return -1, "æ— æ³•ç¡®å®šç‰ˆæœ¬è¾¹ç•Œ"

    def generate_archive_filename(self) -> str:
        """ç”Ÿæˆå­˜æ¡£æ–‡ä»¶å: PLANNING-archive-vX.X.md"""
        with open(self.file_path, 'r', encoding='utf-8') as f:
            content = f.read()

        match = re.search(r'\*\*ç‰ˆæœ¬\*\*:\s*v([\d.]+)', content)
        if match:
            version = match.group(1)
            return f"PLANNING-archive-v{version}.md"
        else:
            today = datetime.now()
            return f"PLANNING-archive-{today.strftime('%Y%m%d')}.md"


class WeekBasedArchive(ArchiveStrategy):
    """åŸºäºå‘¨çš„å­˜æ¡£ç­–ç•¥ (ç”¨äº CONTEXT.md)"""

    def identify_content_structure(self, content: str) -> Dict:
        """è¯†åˆ« CONTEXT.md çš„å‘¨æœŸç»“æ„"""
        weeks = {}
        lines = content.split('\n')

        # ä» "æœ€åä¼šè¯" æ—¥æœŸè§£æå‘¨ä¿¡æ¯
        for line in lines:
            match = re.search(r'\*\*æœ€åä¼šè¯\*\*:\s*(\d{4})-(\d{2})-(\d{2})', line)
            if match:
                year, month, day = int(match.group(1)), int(match.group(2)), int(match.group(3))
                date = datetime(year, month, day)
                week_num = date.isocalendar()[1]
                weeks['last_session'] = {
                    'date': date,
                    'week': week_num,
                    'year': year
                }
                break

        return weeks

    def determine_archive_boundary(self, structure: Dict) -> Tuple[int, str]:
        """ç¡®å®šå­˜æ¡£åˆ†ç•Œçº¿ï¼šä¿ç•™æœ€è¿‘ 2 å‘¨ï¼Œå½’æ¡£æ›´æ—©çš„"""
        lines = []
        with open(self.file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        # CONTEXT.md é€šå¸¸å¾ˆå°ï¼Œä¿ç•™æœ€åçº¦ 20 è¡Œ
        boundary = max(0, len(lines) - 20)

        if boundary > 0 and boundary < len(lines):
            return boundary, "ä¿ç•™æœ€è¿‘ä¼šè¯ä¿¡æ¯ï¼ˆ2 å‘¨å†…ï¼‰ï¼Œå½’æ¡£æ›´æ—©è®°å½•"
        else:
            return -1, "æ–‡ä»¶å†…å®¹ä¸è¶³ä»¥å½’æ¡£"

    def generate_archive_filename(self) -> str:
        """ç”Ÿæˆå­˜æ¡£æ–‡ä»¶å: CONTEXT-archive-YYYY-wXX.md"""
        today = datetime.now()
        week_num = today.isocalendar()[1]
        year = today.year
        return f"CONTEXT-archive-{year}-w{week_num:02d}.md"


# ============================================
# ä¸»ç±»: ArchiveSmart
# ============================================

class ArchiveSmart:
    """æ™ºèƒ½æ–‡æ¡£å­˜æ¡£ç³»ç»Ÿçš„ä¸»ç±»"""

    def __init__(self, config_path: str = 'doc_limits.yaml'):
        """åˆå§‹åŒ–é…ç½®"""
        self.config = self._load_config(config_path)
        self.strategies = self._init_strategies()

    def _load_config(self, config_path: str) -> Dict:
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        if not os.path.exists(config_path):
            # å°è¯•ä»å…¨å±€ä½ç½®åŠ è½½
            config_path = os.path.expanduser('~/.claude/commands/doc_limits.yaml')

        if not os.path.exists(config_path):
            print(f"âŒ é”™è¯¯: æ‰¾ä¸åˆ°é…ç½®æ–‡ä»¶ {config_path}")
            sys.exit(1)

        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            print(f"âŒ é”™è¯¯: åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥ - {e}")
            sys.exit(1)

    def _init_strategies(self) -> Dict[str, type]:
        """åˆå§‹åŒ–å­˜æ¡£ç­–ç•¥æ˜ å°„"""
        return {
            'TASK.md': PhaseBasedArchive,
            'PLANNING.md': VersionBasedArchive,
            'CONTEXT.md': WeekBasedArchive,
        }

    def _get_strategy(self, file_path: str) -> Optional[ArchiveStrategy]:
        """æ ¹æ®æ–‡ä»¶è·¯å¾„è·å–å¯¹åº”çš„ç­–ç•¥"""
        doc_name = Path(file_path).name

        if doc_name not in self.strategies:
            return None

        # è·å–é…ç½®ä¸­çš„å­˜æ¡£è§„åˆ™
        archive_rules = self.config.get('archive_rules', {})
        rule_config = archive_rules.get(doc_name, {})

        strategy_class = self.strategies[doc_name]
        return strategy_class(rule_config, file_path)

    def archive_file(self, file_path: str, dry_run: bool = False) -> ArchiveResult:
        """å¯¹å•ä¸ªæ–‡ä»¶æ‰§è¡Œå­˜æ¡£"""
        strategy = self._get_strategy(file_path)

        if strategy is None:
            return ArchiveResult(
                success=False,
                file_path=file_path,
                original_lines=0,
                archived_lines=0,
                kept_lines=0,
                error_message=f"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: {Path(file_path).name}"
            )

        return strategy.execute_archive(dry_run=dry_run)

    def batch_archive(self, dry_run: bool = False) -> List[ArchiveResult]:
        """æ‰¹é‡å­˜æ¡£æ‰€æœ‰è¶…é™æ–‡æ¡£"""
        results = []
        limits = self.config.get('document_limits', {})

        for file_path, limit in limits.items():
            if not os.path.exists(file_path):
                continue

            # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = len(f.readlines())

            threshold = self.config.get('archive_triggers', {}).get('auto_threshold', 0.8)
            if lines > limit * threshold:
                result = self.archive_file(file_path, dry_run=dry_run)
                results.append(result)

        return results

    def print_report(self, results: List[ArchiveResult], dry_run: bool = False):
        """æ‰“å°æ“ä½œæŠ¥å‘Š"""
        print("\n" + "=" * 80)
        print("ğŸ“Š å­˜æ¡£æ“ä½œæŠ¥å‘Š")
        print("=" * 80)

        if dry_run:
            print("âš ï¸ é¢„è§ˆæ¨¡å¼ (dry-run) - æœªå®é™…æ‰§è¡Œä»»ä½•æ“ä½œ\n")

        if not results:
            print("âœ… æ²¡æœ‰éœ€è¦å­˜æ¡£çš„æ–‡æ¡£\n")
            return

        successful = [r for r in results if r.success]
        failed = [r for r in results if not r.success]

        # æˆåŠŸçš„å­˜æ¡£
        if successful:
            print(f"\nâœ… æˆåŠŸå­˜æ¡£ {len(successful)} ä¸ªæ–‡ä»¶:\n")
            for result in successful:
                print(f"  ğŸ“„ {result.file_path}")
                print(f"     åŸå§‹è¡Œæ•°: {result.original_lines}")
                print(f"     ä¿ç•™è¡Œæ•°: {result.kept_lines}")
                print(f"     å½’æ¡£è¡Œæ•°: {result.archived_lines}")
                print(f"     å­˜æ¡£ä½ç½®: {result.archive_file}\n")

        # å¤±è´¥çš„æ“ä½œ
        if failed:
            print(f"\nâŒ å¤±è´¥ {len(failed)} ä¸ªæ–‡ä»¶:\n")
            for result in failed:
                print(f"  ğŸ“„ {result.file_path}")
                print(f"     é”™è¯¯: {result.error_message}\n")

        # ç»Ÿè®¡ä¿¡æ¯
        total_lines_archived = sum(r.archived_lines for r in successful)
        print("=" * 80)
        print(f"ğŸ“ˆ ç»Ÿè®¡: å…±å­˜æ¡£ {total_lines_archived} è¡Œå†…å®¹")
        print("=" * 80 + "\n")


# ============================================
# å‘½ä»¤è¡Œæ¥å£
# ============================================

def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description='æ™ºèƒ½æ–‡æ¡£å­˜æ¡£è„šæœ¬ - è‡ªåŠ¨è¯†åˆ«å¹¶å­˜æ¡£è¶…é™æ–‡æ¡£',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  # å­˜æ¡£æŒ‡å®šæ–‡ä»¶
  python scripts/archive_smart.py --file docs/management/TASK.md

  # é¢„è§ˆå­˜æ¡£æ•ˆæœï¼ˆä¸å®é™…ä¿®æ”¹æ–‡ä»¶ï¼‰
  python scripts/archive_smart.py --file docs/management/TASK.md --dry-run

  # è‡ªåŠ¨ç¡®è®¤ï¼ˆæ— éœ€äº¤äº’æç¤ºï¼‰
  python scripts/archive_smart.py --file docs/management/TASK.md --auto

  # æ‰¹é‡å­˜æ¡£æ‰€æœ‰è¶…é™æ–‡æ¡£
  python scripts/archive_smart.py --batch

  # é¢„è§ˆæ‰¹é‡å­˜æ¡£
  python scripts/archive_smart.py --batch --dry-run
        """
    )

    parser.add_argument(
        '--file',
        type=str,
        help='æŒ‡å®šè¦å­˜æ¡£çš„æ–‡ä»¶è·¯å¾„'
    )
    parser.add_argument(
        '--batch',
        action='store_true',
        help='æ‰¹é‡å­˜æ¡£æ‰€æœ‰è¶…é™æ–‡æ¡£'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='é¢„è§ˆæ¨¡å¼ï¼šæ˜¾ç¤ºæ“ä½œä½†ä¸å®é™…ä¿®æ”¹æ–‡ä»¶'
    )
    parser.add_argument(
        '--auto',
        action='store_true',
        help='è‡ªåŠ¨ç¡®è®¤ï¼šè·³è¿‡äº¤äº’æç¤º'
    )
    parser.add_argument(
        '--config',
        type=str,
        default='doc_limits.yaml',
        help='é…ç½®æ–‡ä»¶è·¯å¾„ï¼ˆé»˜è®¤: doc_limits.yamlï¼‰'
    )

    args = parser.parse_args()

    # éªŒè¯å‚æ•°
    if not args.file and not args.batch:
        parser.print_help()
        sys.exit(1)

    # åˆå§‹åŒ–æ™ºèƒ½å­˜æ¡£ç³»ç»Ÿ
    try:
        archive_smart = ArchiveSmart(args.config)
    except SystemExit:
        sys.exit(1)

    # æ‰§è¡Œå­˜æ¡£æ“ä½œ
    results = []

    if args.batch:
        results = archive_smart.batch_archive(dry_run=args.dry_run)
    elif args.file:
        result = archive_smart.archive_file(args.file, dry_run=args.dry_run)
        results = [result]

    # æ‰“å°æŠ¥å‘Š
    archive_smart.print_report(results, dry_run=args.dry_run)

    # ç¡®å®šé€€å‡ºç 
    failed_count = sum(1 for r in results if not r.success)
    sys.exit(1 if failed_count > 0 else 0)


if __name__ == '__main__':
    main()
