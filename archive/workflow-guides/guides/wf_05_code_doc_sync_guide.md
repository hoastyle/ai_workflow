---
title: "wf_05_code 文档同步决策树指南"
description: "代码完成后的约束驱动文档决策系统，自动化分层、成本门控和索引更新"
type: "技术设计"
status: "完成"
priority: "高"
created_date: "2025-11-27"
last_updated: "2025-11-27"
related_documents:
  - "../../wf_05_code.md"
  - "../../KNOWLEDGE.md"
  - "../reference/FRONTMATTER.md"
related_code: []
---

# wf_05_code 文档同步决策树指南

本文档详细说明 `/wf_05_code` 代码完成后的 **Phase 2: 文档同步决策树** (Step 8)，确保代码和文档始终对齐。

---

## 核心原则

**文档是代码的一等公民** - 代码完成后 **必须** 执行此步骤，不是可选项。

---

## Step 8.1: 文档变更范围确定（强制检查清单）

执行此检查列表，**必须逐一决策**：

```
□ Q1: 添加或修改了公开 API/函数/类？
      (数据结构、函数签名、导出接口)

□ Q2: 改变了现有功能的行为？
      (功能变更、参数改变、返回值变化)

□ Q3: 使用了新的库、框架或技术依赖？
      (第三方库、新框架、新工具)

□ Q4: 改变了系统架构或设计？
      (模块重组、新设计模式、性能优化决策)

□ Q5: 引入了新的配置或部署流程改动？
      (环境变量、配置文件、部署步骤)
```

**决策规则**:
- **如果任何一项是 YES** → 继续 Step 8.2 (文档分层决策)
- **如果全部 NO** → 跳到 Step 8.3 (索引更新验证)

---

## Step 8.2: 按层级路由文档决策树（自动化分层）

### 文档决策树

```
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ 文档决策树：根据改动类型自动路由到正确的层            ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

[START] - 这个改动是什么类型？

├─ 类型A: 项目级架构改动（影响整体设计）
│  ├─ 信号：改变了系统核心层次、模块拆分、技术栈选择
│  └─ 决策：更新 PLANNING.md
│     ├─ 约束: 新增内容 < 50 行
│     ├─ 规则: 仅记录"为什么"和"架构影响"
│     └─ 例子: "重构用户认证层，从 Session → JWT"
│
├─ 类型B: 架构决策（需要记录原因和权衡）
│  ├─ 信号：多个方案权衡、长期影响、异常处理方案
│  └─ 决策：创建或更新 ADR → docs/adr/
│     ├─ 约束: < 200 行
│     ├─ 规则: 遵循 ADR TEMPLATE.md 模板
│     └─ 例子: "为什么选择异步队列而非同步处理"
│
├─ 类型C: API/功能文档（开发者需要了解用法）
│  ├─ 信号：新 API、功能变更、使用示例、配置说明
│  └─ 决策：添加/更新技术文档 → docs/
│     ├─ 约束: 单个文件 < 500 行
│     ├─ 规则:
│     │  • 遵循 Frontmatter 元数据规范
│     │  • 从代码提取，不是编造内容
│     │  • 包含实际的代码示例
│     └─ 例子: 新 API 端点的使用说明，参数和返回值
│
├─ 类型D: 常见问题或最佳实践（其他开发者可能遇到）
│  ├─ 信号：解决方案模式、常见错误、排查指南
│  └─ 决策：提议添加到 KNOWLEDGE.md § FAQ
│     ├─ 约束: 每个 Q < 50 行
│     ├─ 规则: 月末批量审查合并（不要频繁更新）
│     └─ 例子: "如何处理并发请求的竞态条件"
│
└─ 类型E: 上述都不是，代码更改但不需要文档
   └─ 决策：跳过文档同步，继续 8.3
      ├─ 例子: 内部函数重构、变量名改进、测试添加
      └─ 记录: 在 git commit message 中说明"无文档变更"
```

### 决策方法

1. **识别改动属于 A/B/C/D/E 中的哪一类**
   - 根据"信号"判断改动的性质
   - 查看"例子"确认分类正确

2. **按对应的约束执行**（如果需要文档）
   - 每种类型都有明确的约束（行数限制、规则要求）
   - 严格遵守约束，避免文档膨胀

3. **关键原则：不跨层级混合**
   - 类型 C (API 文档) 不应放在类型 D (FAQ) 位置
   - 每种类型有其专门的位置和格式

---

## Step 8.3: 自动更新文档索引（强制自动化）

### 如果生成或更新了任何文档，必须运行：

#### 1. 验证 Frontmatter 完整性

```bash
# 验证所有新文档都有完整的 Frontmatter
python ~/.claude/commands/scripts/frontmatter_utils.py validate docs/

# 输出示例:
# ✅ 通过 - 所有文档都有完整的 Frontmatter
# ❌ 失败 - docs/api/auth.md 缺失字段: priority, created_date
```

#### 2. 自动更新 KNOWLEDGE.md 索引

```bash
# 自动更新 KNOWLEDGE.md 的文档索引
python ~/.claude/commands/scripts/frontmatter_utils.py update-index KNOWLEDGE.md

# 输出示例:
# ✅ 新增索引条目: docs/api/auth.md
# ✅ 更新索引条目: docs/api/user.md (last_updated 变化)
```

#### 3. 生成文档关系图（可选，用于理解依赖）

```bash
# 生成文档关系图
python ~/.claude/commands/scripts/doc_graph_builder.py generate docs/

# 输出示例:
# ✅ 生成 docs/relationships.md (文档网络可视化)
```

### 失败处理

- ❌ **Frontmatter 验证失败** → 修复缺失字段（参考 `CLAUDE.md § Frontmatter 规范`）
- ❌ **索引更新失败** → 检查脚本是否存在，或手工更新 KNOWLEDGE.md

---

## Step 8.4: 成本检查门控（强制成本约束）

在步骤 8.3 后必须通过此检查，**否则拒绝进入下一步**：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 文档成本检查门控
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

检查项目                        限制          实际值      状态
─────────────────────────────────────────────────────────
KNOWLEDGE.md 行数               < 200 行       ?         ✅/❌
新增/修改的 docs/ 文件          < 500 行       ?         ✅/❌
新增 ADR 大小                   < 200 行       ?         ✅/❌
docs/ 总大小增长                < 30%          ?         ✅/❌
KNOWLEDGE.md 增长               < 20%          ?         ✅/❌

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 成本检查失败时的处理方案

#### 🔴 立即失败，必须修复

- **KNOWLEDGE.md > 200 行** → 拆分到 `docs/knowledge/`
- **新文档 > 500 行** → 分章节或拆成多个文件
- **ADR > 200 行** → 精简或移除冗余内容

#### 🟠 警告，需要改进

- **docs/ 增长 > 30%** → 评估是否有重复，是否需要归档旧文档
- **KNOWLEDGE.md 增长 > 20%** → 检查是否有可以外放的内容

### 如果无法通过成本检查

选择以下方案之一：

1. **修改新增文档的范围**（减少内容）
2. **先运行 `/wf_13_doc_maintain` 清理旧文档**，再提交新文档
3. **分多个 commit 逐步添加文档**

---

## Step 8.5: 决策记录和承诺（强制明确化）

### 在 git commit message 中记录此次的文档决策

#### 示例 1: 有文档更改

```bash
feat: 实现用户认证功能

文档决策:
- [类型C] 新增 docs/api/auth.md (认证 API 说明, 120 行)
  ├─ Frontmatter: ✅ 完整
  ├─ 成本检查: ✅ 通过
  └─ 索引更新: ✅ KNOWLEDGE.md 已更新

- [类型B] 新增 ADR: 为什么选择 JWT 而非 Session
  ├─ 文件: docs/adr/2025-11-18-jwt-over-session.md (145 行)
  └─ 索引: KNOWLEDGE.md ADR 表已更新

文档成本汇总:
- KNOWLEDGE.md: 150 → 155 行 (+3%, ✅)
- docs/: 2400 → 2600 行 (+8%, ✅)
- 新增文件: 2 个，总 265 行

无破损链接: ✅ 验证通过
```

#### 示例 2: 无文档更改

```bash
feat: 优化认证性能

文档决策:
- [类型E] 无文档变更
  原因: 内部性能优化，不涉及 API 或架构改动

影响范围: 仅性能改善，兼容现有接口
```

---

## Step 8.6: 准备进入下一步（工作流连接）

### 完成 8.1-8.5 后，代码和文档已经对齐

### 下一步建议

```bash
# 文档同步完成后，进入测试和审查流程

# 选项A：先测试（推荐）
/wf_07_test "为 [功能] 编写单元测试"

# 选项B：直接审查（简单功能）
/wf_08_review

# 注意：/wf_08_review 会再次检查文档架构合规性
#      如果本步骤执行正确，审查应该通过文档部分
```

---

## 快速参考

### 决策流程总览

```
代码完成
  ↓
8.1: 检查是否需要文档 (Q1-Q5)
  ↓
8.2: 确定文档类型 (A/B/C/D/E)
  ↓
8.3: 验证 Frontmatter + 更新索引
  ↓
8.4: 成本检查门控
  ↓
8.5: 记录在 commit message
  ↓
8.6: 进入下一步 (/wf_07_test 或 /wf_08_review)
```

### 文档类型快速查找表

| 改动类型 | 文档类型 | 位置 | 约束 |
|---------|---------|------|------|
| 系统核心架构改动 | 类型A | PLANNING.md | < 50 行 |
| 技术决策和权衡 | 类型B | docs/adr/ | < 200 行 |
| 新 API/功能 | 类型C | docs/ | < 500 行 |
| 常见问题/最佳实践 | 类型D | KNOWLEDGE.md § FAQ | < 50 行/Q |
| 内部重构/优化 | 类型E | 无文档 | - |

---

## 相关内容

详见:
- [wf_05_code.md](../../wf_05_code.md) - 主命令文档
- [CLAUDE.md](../../CLAUDE.md) - Frontmatter 规范和文档架构
- [docs/reference/FRONTMATTER.md](../reference/FRONTMATTER.md) - Frontmatter 元数据规范
- [KNOWLEDGE.md](../../KNOWLEDGE.md) - 知识库和文档索引
