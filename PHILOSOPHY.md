# 🎨 设计哲学指南 (Philosophy)

**版本**: v1.0
**最后更新**: 2025-11-06
**状态**: Active

---

## 序言：Ultrathink 是什么？

Ultrathink 不是一种具体的技术，而是一种**设计思维方式和工程哲学**。它强调：

- 🧠 **深度思考** - 不接受第一个能工作的方案，追求最优雅的解决方案
- 🎯 **目标导向** - 明确问题的本质，而不仅仅是症状
- 🔄 **迭代完善** - 不懈地打磨每一个细节，直到达到"不得不这样"的程度
- ⚖️ **权衡意识** - 每个决策都涉及取舍，明确认知这些权衡
- 📖 **沉淀学习** - 将决策的"为什么"记录下来，形成项目资产

## 与 CLAUDE.md 的关系

| 维度 | CLAUDE.md | PHILOSOPHY.md |
|------|-----------|---------------|
| **职责** | 执行规范和权限矩阵 | 设计思维和决策框架 |
| **例子** | "使用 /wf_11_commit 提交" | "提交前问自己，这段代码优雅吗？" |
| **强制性** | ✅ 强制遵守 | ❌ 可选的补充视角 |
| **应用场景** | 所有开发阶段 | 需要做出关键决策时 |
| **冲突时** | CLAUDE.md 优先（执行规范 > 设计视角） | - |

**关键原则**: Ultrathink 是在遵循 CLAUDE.md 规范的基础上，追求更高的**设计优雅度**。

---

## 6 个核心原则

### 1️⃣ Think Different - 质疑假设，追求最优

**核心思想**: 第一个能工作的方案往往不是最优的。在开始编码前，停下来问自己：

- 为什么一定要这样做？
- 如果我从零开始，会怎么设计？
- 隐藏的假设是什么？
- 是否有更优雅的方式？

**应用场景**:
- 架构设计决策（选择框架、数据库、API设计）
- 算法选择（是否有更高效或更清晰的方式？）
- 系统边界划分（模块职责是否合理？）

**反面案例**:
- ❌ "这样做能工作，就这样吧" → 早期技术债积累
- ❌ 盲目跟风新技术，不问是否适合 → 系统复杂度爆炸
- ❌ 只考虑当前需求，不想象未来 → 后期重构成本高

**典型问题**:
- "我应该用 REST 还是 GraphQL？"
- "数据库应该用关系型还是文档型？"
- "这个功能应该在前端还是后端实现？"

---

### 2️⃣ Obsess Over Details - 观察细节，理解灵魂

**核心思想**: 优雅的代码往往体现在细节里。函数名、变量名、代码结构都在"说话"。

- 函数名是否**自洽而直观**？（是否能从名字推断出行为？）
- 变量名是否**消除了歧义**？（是否用domain语言而不是缩写？）
- 代码结构是否**自然流畅**？（读起来像在说故事吗？）
- 边界情况是否**被体贴地处理**？（错误处理优雅吗？）

**应用场景**:
- 代码审查（不仅看功能，还看优雅度）
- 代码实现（命名和结构设计）
- 文档编写（表达是否清晰而精准）

**反面案例**:
- ❌ 变量名: `a, temp, result, data` → 模糊不清
- ❌ 函数名: `process(), handle(), do_something()` → 职责不明确
- ❌ 错误处理: 吞掉异常或只返回 null → 调用者无法判断真实状态

**典型问题**:
- "这个函数的名字能再好一点吗？"
- "有没有更自然的代码组织方式？"
- "这个 API 的参数顺序合理吗？"

---

### 3️⃣ Plan Like Da Vinci - 精心规划，清晰架构

**核心思想**: 在动手之前，在脑海或纸上**素描出架构的样貌**。这样做：
- 避免编码中的返工
- 让设计思路清晰可验证
- 便于与他人沟通

**规划的层次**:
1. **问题空间** - 需要解决什么？有什么约束？
2. **设计空间** - 有哪些可能的方案？
3. **决策矩阵** - 每个方案的优缺点是什么？
4. **最终方案** - 为什么选这个？权衡是什么？

**应用场景**:
- 大功能的实现规划
- 系统重构或优化前
- 架构设计审查
- 团队协作讨论

**反面案例**:
- ❌ "我有个idea，直接开始写" → 中途发现设计问题，大幅返工
- ❌ "方案看起来行，先做吧" → 做到一半发现无法扩展
- ❌ 方案没有文档，只在脑子里 → 后来者无法理解"为什么这样"

**典型问题**:
- "这个功能的架构应该怎么分层？"
- "这次重构的目标是什么，范围是什么？"
- "有没有更好的设计方案我没想到？"

---

### 4️⃣ Craft, Don't Code - 优雅实现，自然抽象

**核心思想**: 编码是**手艺活**。每一行代码都应该被精心打磨，就像木工精心打磨木制品。

**关键指标**:
- **自然性** - 代码读起来像自然语言，符合 domain 思维
- **必然性** - "不得不这样"，没有多余的复杂性
- **和谐性** - 与系统既有的代码风格和模式一致
- **容错性** - 边界情况被体贴地处理，错误信息清晰有用

**应用场景**:
- 功能实现（选择最优雅的算法和数据结构）
- 代码审查（发现不优雅的代码并建议改进）
- 代码组织（模块划分、接口设计）

**反面案例**:
- ❌ 代码能工作但充满技巧和黑魔法 → 难以维护
- ❌ 过度工程化，简单问题复杂化 → 代码行数多且难以理解
- ❌ 风格不一致，每段代码看起来都像不同的人写的 → 整体混乱

**典型问题**:
- "这个算法有没有更清晰的实现方式？"
- "这个接口设计合理吗？"
- "能不能用更简洁的方式表达同样的逻辑？"

---

### 5️⃣ Iterate Relentlessly - 迭代完善，不断精进

**核心思想**: 没有"完成"，只有"目前为止最好的版本"。好的代码是**迭代打磨**出来的。

**迭代的循环**:
1. **实现 v1** - 能工作就好
2. **运行 & 测试** - 看看实际表现
3. **截图和对比** - 与设计目标对比
4. **识别改进点** - 哪里不够优雅？
5. **精进** - 打磨细节
6. 回到步骤 2

**应用场景**:
- 功能开发的每个阶段
- 性能优化（测试 → 瓶颈识别 → 优化 → 验证）
- 代码质量提升（审查 → 改进 → 验证）

**反面案例**:
- ❌ "第一版是草稿，先发布" → 用户用到劣质产品
- ❌ "完成就算了" → 错过进一步优化的机会
- ❌ "看不出性能问题，不用优化" → 后续成为瓶颈

**典型问题**:
- "这个实现能不能再简洁一点？"
- "这个性能指标是否达到目标？"
- "有没有边界情况我遗漏的？"

---

### 6️⃣ Simplify Ruthlessly - 无情简化，去除复杂性

**核心思想**: 优雅的设计的标志不是"什么都能做"，而是"用最少的概念做需要的事"。

**简化的原则**:
- **优先删除** - 不需要的功能删掉，比添加新功能更重要
- **统一概念** - 10个相似的概念能否合并为 2-3 个？
- **清晰的边界** - 每个组件的职责清晰，不越界
- **最小化接口** - API 的参数和返回值越少越好

**应用场景**:
- 代码重构（移除重复、合并相似逻辑）
- 功能设计（砍掉不必要的特性）
- API 设计（最小化参数，清晰的返回值）

**反面案例**:
- ❌ "以后可能用得上，先加上" → 过度设计，维护负担
- ❌ "支持各种使用场景" → API 复杂度爆炸，没人能记住
- ❌ "代码能工作就行" → 重复代码、冗余逻辑积累

**典型问题**:
- "这个功能真的需要吗？"
- "能不能去掉一些参数，让 API 更简洁？"
- "这堆概念能不能简化为一个？"

---

## 何时使用 Ultrathink 视角？

### ✅ 应该用的场景

| 场景 | 原因 | 相关命令 |
|------|------|---------|
| **架构设计决策** | 早期决策影响深远，应该深思 | `/wf_04_ask` |
| **关键抽象设计** | 影响整个模块的代码风格 | `/wf_05_code` |
| **代码审查** | 除了功能，还要看设计优雅度 | `/wf_08_review` |
| **重构或优化** | 每个决策都涉及权衡，应该明确 | `/wf_09_refactor`, `/wf_10_optimize` |
| **跨越若干提交的大改动** | 需要确保方向正确 | `/wf_04_ask` → `/wf_05_code` |
| **"为什么这样不行？"** | 通常隐藏了更深的设计问题 | `/wf_06_debug` + ultrathink |

### ❌ 不需要用的场景

| 场景 | 原因 |
|------|------|
| **简单的 bug 修复** | 已经明确问题所在，直接修即可 |
| **例行的小任务** | 代码改动小，没有设计选择 |
| **紧急的线上故障** | 先救火，事后再反思 |
| **跟随规范的修改** | 设计已定，只需按规范实现 |
| **已有成熟模式的实现** | 直接参照既有模式即可 |

---

## 与工作流命令的对应关系

### 🟢 /wf_04_ask - 架构咨询
**Ultrathink 原则**: Think Different + Plan Like Da Vinci
- 质疑所有假设，找出最优方案
- 在多个选项间权衡，明确理由
- 将决策记录到 `docs/adr/`

**触发条件**: 用户面对技术选择时
**自动提示**: "从设计的角度，我看到以下选项..."

---

### 🟢 /wf_05_code - 代码实现
**Ultrathink 原则**: Craft, Don't Code + Plan Like Da Vinci
- 实现前思考架构（模块划分、接口设计）
- 优雅的命名和代码组织
- 细致的错误处理

**触发条件**: 实现关键功能或新模块时
**自动提示**: "这个模块的边界是什么？函数名合适吗？"

---

### 🟢 /wf_08_review - 代码审查
**Ultrathink 原则**: Obsess Over Details
- 除了功能正确，还要看设计优雅度
- 函数名、变量名是否自然？
- 代码结构是否易于理解？

**触发条件**: 完成功能实现后的代码审查
**自动提示**: "代码功能正确，但从设计的角度有改进空间吗？"

---

### 🟡 /wf_09_refactor - 代码重构
**Ultrathink 原则**: Simplify Ruthlessly + Iterate Relentlessly
- 移除重复和冗余
- 统一相似的概念
- 迭代打磨细节

**触发条件**: 识别出设计不够优雅的代码时
**自动提示**: "这个权衡（性能 vs 可读性）是否清晰？"

---

### 🟡 /wf_10_optimize - 性能优化
**Ultrathink 原则**: Iterate Relentlessly + 权衡意识
- 性能和可读性的权衡
- 每次优化的成本-收益分析
- 明确记录优化理由

**触发条件**: 性能瓶颈需要优化时
**自动提示**: "这个优化的权衡是什么？值得吗？"

---

### 🔵 /wf_06_debug - 调试修复
**Ultrathink 原则**: Think Different（可选）
- 不仅修复症状，还要追问根本原因
- "为什么会这样？"背后通常隐藏设计问题

**触发条件**: 修复的 bug 重复出现或影响面大时
**自动提示**: "这个 bug 的根本原因是什么？设计层面能改进吗？"

---

## 案例分析

### 案例 1: 数据库选择决策

**场景**: 新项目需要选择数据库（SQLite vs PostgreSQL vs MongoDB）

**不用 Ultrathink**:
- "用 PostgreSQL 吧，大家都用它"
- 几周后发现查询性能不符合预期，需要大量优化

**用 Ultrathink**:
1. **Think Different** - 问题的本质是什么？
   - 数据量预期？并发度？查询复杂度？
   - 不同数据库的权衡是什么？

2. **Plan Like Da Vinci** - 比较决策矩阵
   - SQLite: 简单快速，但并发能力有限
   - PostgreSQL: 功能全面，但复杂度高
   - MongoDB: 灵活，但事务支持有限

3. **Simplify Ruthlessly** - 真的需要那么强大吗？
   - 如果数据简单且无复杂查询，SQLite 足矣
   - 减少系统复杂度

4. **决策与权衡记录** (docs/adr/)
   - 选择 SQLite
   - 理由: 数据简单、并发低、快速开发
   - 权衡: 失去水平扩展能力，但通过缓存补偿
   - 如果数据/并发增长，重新评估

---

### 案例 2: API 设计

**场景**: 设计用户认证 API

**不用 Ultrathink**:
```python
def auth(username, password, remember_me=False,
         two_factor_code=None, device_id=None, ...):
    pass
```

**用 Ultrathink**:
1. **Obsess Over Details** - 参数名字清晰吗？
   - `username` vs `user_id` - 哪个更准确？
   - `remember_me` 的含义？

2. **Simplify Ruthlessly** - 能否减少参数？
   - 两步认证的流程能否分离？
   - Device ID 真的需要在第一步传吗？

3. **最终设计**:
```python
def authenticate(user_id: str, password: str) -> AuthToken:
    """第一步：基础认证"""
    pass

def verify_two_factor(auth_token: str, code: str) -> SessionToken:
    """第二步：二次验证（如果需要）"""
    pass
```

- 更清晰、更简洁、更容易理解

---

## 与项目管理的关系

### 设计决策记录 (ADR)

Ultrathink 强调将重要决策的"为什么"记录下来，这些记录存储在 `docs/adr/` 目录：

```markdown
# 2025-11-06-use-sqlite-instead-of-postgres.md

## 决策
使用 SQLite 而非 PostgreSQL 作为初始数据库

## 背景
新项目对数据库的需求尚不清晰

## 选项分析
- **SQLite**: 简单快速，开发便捷，但无水平扩展
- **PostgreSQL**: 功能全面，生产就绪，但复杂度高
- **MongoDB**: 灵活，但事务支持有限

## 决策理由
1. 初期数据结构简单，关系数据库足矣
2. 并发需求不高（< 100 concurrent users）
3. 快速迭代优于前期完美

## 权衡与成本
- **收益**: 快速开发，低运维成本
- **成本**: 后期若扩展，需要迁移到 PostgreSQL
- **风险**: 如果并发突然增长，需要紧急迁移

## 后续计划
- 监控并发数量和查询性能
- 如果超过阈值（> 50 concurrent, 查询 > 100ms），重新评估
```

这样做的好处：
- 🧠 新加入团队的成员能理解"为什么"
- 🔮 后期回顾时，能看到当时的思考过程
- 📚 积累成为项目的设计资产

---

## 如何在工作中应用 Ultrathink

### 快速检查清单

**在做任何设计决策前，问自己**:

- [ ] **Think Different** - 我质疑了所有假设吗？
- [ ] **Obsess Over Details** - 细节上能更优雅吗？（命名、结构）
- [ ] **Plan Like Da Vinci** - 方案清晰且可验证吗？
- [ ] **Craft, Don't Code** - 实现是优雅的吗？
- [ ] **Iterate Relentlessly** - 我打磨过这个设计吗？
- [ ] **Simplify Ruthlessly** - 有没有不必要的复杂性能移除？

### 与 AI 助手的协作

你可以在任何时候请求 ultrathink 视角：

```bash
# 例子 1: 架构咨询
/wf_04_ask "应该用 REST 还是 GraphQL？"
# AI 会问: 您想从设计哲学的角度深入分析吗？

# 例子 2: 代码审查
/wf_08_review
# AI 会检查代码的优雅度，不仅仅是功能正确

# 例子 3: 重构分析
/wf_09_refactor "性能 vs 可读性，我应该怎么权衡？"
# AI 会帮你明确权衡并记录到 docs/adr/
```

---

## 常见问题

**Q: 追求优雅不会让开发变慢吗？**
A: 短期看起来慢，但长期能省时间。一个设计不优雅的系统，后期维护和扩展成本极高。提前投入时间做好设计，后面的日子更轻松。

**Q: 什么时候应该停止打磨，开始发布？**
A: 当代码达到"不得不这样"的程度时。不追求完美，追求必然。如果继续改进带不来显著收益，就该发布了。

**Q: 这和完美主义有什么区别？**
A: 完美主义是追求"无可挑剔"，通常过度设计。Ultrathink 是追求"必然优雅"，知道什么时候够好了。

**Q: 团队成员对设计的理解不同怎么办？**
A: 这就是为什么要把决策记录到 `docs/adr/`。写清楚权衡和理由，新成员能学到团队的设计理念。

**Q: 这会增加代码审查的时间吗？**
A: 初期可能会，但长期能减少 bug 和返工。而且共同的设计理念能加速团队合作。

---

## 总结

Ultrathink 不是一套复杂的规则，而是一种**思维习惯**：

1. 🧠 **深度思考** - 不着急，先想清楚
2. 📐 **精心设计** - 在动手前，先素描
3. ✨ **优雅实现** - 每一行代码都被精心打磨
4. 🔄 **迭代完善** - 没有"完成"，只有"更好"
5. ⚖️ **明确权衡** - 每个决策都有成本，要知道自己在权衡什么
6. 📚 **沉淀学习** - 将"为什么"记录下来

配合项目的工作流系统 (CLAUDE.md) 使用，Ultrathink 能帮你写出**不仅正确、而且优雅的代码**。

---

**最后更新**: 2025-11-06
**维护者**: AI Design Philosophy System
**相关文档**: [CLAUDE.md](CLAUDE.md), [docs/adr/](docs/adr/)
