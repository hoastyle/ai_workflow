# CLAUDE.md

AI 编程助手的项目指南 - Claude Code 工作流和标准规范

This file provides comprehensive guidance to Claude Code (claude.ai/code) for working with this repository's optimized closed-loop workflow command system.

---

## 快速导航目录

| 部分 | 说明 | 适用场景 |
|------|------|---------|
| **[项目规范](#项目规范)** | 语言、文档、代码标准 | 项目启动、新协作者 |
| **[AI 执行规则](#ai-执行规则)** | AI 行为准则和决策逻辑 | ⭐ 所有场景必读 |
| **[核心概念](#核心概念)** | 工作流系统介绍和哲学 | 理解系统设计 |
| **[快速开始](#快速开始指南)** | 4个必用命令 (80% 场景) | 新用户上手 |
| **[完整命令参考](#命令完整参考)** | 13个工作流命令详解 | 命令查询和使用 |
| **[工作流决策树](#工作流决策树)** | 场景-命令映射 | 选择合适的命令 |
| **[完整工作流模式](#完整工作流模式)** | 常见开发流程 | 实际工作参考 |
| **[核心文件说明](#核心文件说明)** | 项目管理文档 | 文档管理和维护 |
| **[开发标准](#开发标准)** | 代码质量和流程规范 | 代码审查、提交 |
| **[最佳实践](#最佳实践-故障排除)** | 常见问题和解决方案 | 问题排查 |

---

## 项目规范

### 语言规范

本项目采用分层语言策略，确保清晰的交互和一致的代码：

1. **交互沟通**: 中文
   - 用户和 Claude 之间的交互使用中文
   - 文档说明、注释使用中文便于理解

2. **文档**: 中文
   - 所有项目管理文档（PRD.md, PLANNING.md, TASK.md, CONTEXT.md, KNOWLEDGE.md）使用中文
   - README、指南、规范文档使用中文

3. **代码实现**: 英文
   - 代码中的所有变量、函数、类名使用英文
   - 代码注释遵循项目历史惯例
   - 专有名词和缩写保持英文

4. **代码提交**: 参考历史
   - 查看项目的既有提交信息
   - 如果历史提交大部分为中文，使用中文提交信息
   - 否则使用英文提交信息
   - 确保提交信息风格一致

### 项目管理文档结构

所有项目管理类文档应在 `docs/management/` 目录下构建和管理：

| 文件 | 用途 | 维护者 |
|-----|------|--------|
| **PRD.md** | 项目需求文档（read-only）| 产品/技术主管 |
| **PLANNING.md** | 技术规划和架构设计 | 项目主导 |
| **TASK.md** | 任务追踪和进度管理 | 开发团队 |
| **CONTEXT.md** | 会话上下文和工作状态 | 自动更新（/wf_11_commit） |
| **KNOWLEDGE.md** | 知识库和决策记录 | 团队积累 |

**关键原则**:
- PRD.md 是只读参考，不自动修改
- 所有命令必须遵守 PRD.md 需求
- 每个决策应在 PLANNING.md 中记录
- CONTEXT.md 由 /wf_11_commit 自动更新以支持会话连续性

---

## AI 执行规则

> ⭐ **核心指令**: 本部分定义 AI 的行为准则、决策逻辑和主动行为规则

### 文件操作权限矩阵

**严格遵守以下权限规则**:

| 文件 | 读取 | 创建 | 修改 | 删除 | 特殊规则 |
|------|:----:|:----:|:----:|:----:|---------|
| **PRD.md** | ✅ | ❌ | ❌ | ❌ | 只读参考。如用户要求修改，必须明确确认并警告影响 |
| **PLANNING.md** | ✅ | ✅ | ✅ | ❌ | 重大技术决策后必须更新。记录"为什么"和 PRD 对齐理由 |
| **TASK.md** | ✅ | ✅ | ✅ | ❌ | 完成任务后立即更新状态。每项任务关联 PRD 需求 |
| **CONTEXT.md** | ✅ | ❌ | ❌ | ❌ | 仅由 `/wf_11_commit` 自动管理。其他命令不得写入 |
| **KNOWLEDGE.md** | ✅ | ✅ | ✅ | ❌ | 发现架构决策、新模式或问题解决方案时添加 ADR |
| **代码文件** | ✅ | ✅ | ✅ | ⚠️ | 遵循 PLANNING.md 标准。删除需用户确认 |

### 会话生命周期规则

#### 🚀 会话开始时 (每次必须检查)

```
1. 检查用户是否运行了 /wf_03_prime
   ├─ 如果是新会话且未运行
   │  └─ 主动提示: "建议先运行 /wf_03_prime 加载项目上下文"
   │
   ├─ 如果是全新项目 (管理文档不存在)
   │  └─ 引导: "这是新项目，建议运行 /wf_01_planning 建立规划"
   │
   └─ 如果已加载上下文
       └─ 简要总结: "已加载项目上下文。当前任务: [从 TASK.md 读取]"
```

#### ⚡ 会话进行中 (持续监控)

**决策前检查**:
- 执行任何技术决策前，在内心确认是否符合 PRD 要求
- 遇到模糊需求，使用 `/wf_04_ask` 的架构师角色分析
- 不确定时，主动询问用户而不是猜测

**进度追踪**:
- 完成任务后，主动提醒更新 TASK.md
- 做重大技术决策后，建议更新 PLANNING.md

#### 💾 会话结束前 (主动建议)

```
如果用户完成了实际工作 (写代码、修复 Bug、重构等):
1. 提醒: "建议运行 /wf_11_commit 保存进度"
2. 说明: "这会自动更新 CONTEXT.md，确保下次会话能恢复工作状态"
3. 如果用户忘记，在对话快结束时再次提醒
```

### 主动行为触发规则

**何时主动提醒用户**:

| 场景 | 触发条件 | 提醒内容 |
|------|---------|---------|
| **会话启动** | 新会话且未运行 prime | "建议先运行 /wf_03_prime 加载上下文" |
| **任务完成** | 用户说"完成了"、"做好了" | "建议运行 /wf_11_commit 保存进度" |
| **发现问题** | 代码有明显 bug | "发现潜在问题，建议使用 /wf_06_debug 系统分析" |
| **需求不清** | 用户需求模糊 | "建议使用 /wf_04_ask 进行架构咨询" |
| **PRD 冲突** | 用户要求与 PRD 冲突 | 明确指出冲突，询问是否覆盖规则 |
| **测试缺失** | 实现功能但无测试 | "建议运行 /wf_07_test 添加测试" |

### 冲突处理决策树

```
用户请求与规则冲突
│
├─ 第1步: 识别冲突类型
│  ├─ PRD 冲突: 用户要求与需求文档不符
│  ├─ 标准冲突: 违反 PLANNING.md 中的开发标准
│  └─ 权限冲突: 要求修改只读文件 (如 PRD.md)
│
├─ 第2步: 暂停执行，向用户解释
│  └─ 说明: "这个操作会 [具体影响]，因为 [规则原因]"
│
├─ 第3步: 询问确认
│  ├─ 用户明确确认 → 执行 + 记录到 KNOWLEDGE.md
│  ├─ 用户取消 → 建议符合规则的替代方案
│  └─ 用户不确定 → 使用 /wf_04_ask 深入分析
```

**示例对话**:
```
用户: "帮我修改 PRD.md，把性能要求降低"
AI: "PRD.md 是项目需求的权威文档，通常由产品/技术主管维护。
     直接修改可能影响团队的需求追溯和版本控制。

     建议方案:
     1. 先在 PLANNING.md 中记录性能优化的技术方案
     2. 与团队讨论后由授权人员更新 PRD.md

     如果您确定要现在修改 PRD.md，我可以帮您，但请确保通知团队。
     是否继续?"
```

### 异常处理规则

#### 文件不存在时的处理

| 文件 | 处理方式 |
|------|---------|
| **PRD.md, PLANNING.md** | 提示新项目，建议: "/wf_01_planning 建立项目规划" |
| **TASK.md** | 创建空白模板，添加初始任务: "开始第一个功能开发" |
| **CONTEXT.md** | 正常情况，首次运行不存在。忽略 |
| **KNOWLEDGE.md** | 创建空白文件，说明: "将在工作中积累知识和决策" |

#### 命令执行失败时的处理

```
1. 使用 /wf_06_debug 的调试协调员角色分析错误
2. 尝试自动修复 (如格式问题、依赖缺失)
3. 如果无法自动修复:
   ├─ 向用户清晰解释问题和原因
   ├─ 提供具体的解决步骤
   └─ 建议是否需要手动处理
4. 将问题和解决方案记录到 KNOWLEDGE.md
```

### 命令调用规则

**工作流命令是 Slash Commands**:
- 格式: `/wf_XX_name` (不是文件路径)
- 按需调用，详细步骤在命令文件中
- AI 负责判断"何时调用哪个命令"

**调用示例**:
```
❌ 错误: "运行 wf_03_prime.md"
✅ 正确: "运行 /wf_03_prime"

❌ 错误: 自己实现命令的详细步骤
✅ 正确: 判断需要使用某命令，然后调用它
```

---

## 核心概念

### 工作流系统概述

这是一个为 Claude Code 优化的闭环工作流命令系统，集成项目规划、任务管理和开发工作流。

**系统特点**:
- 🚀 **快速上手**: 4个必用命令覆盖 80% 的使用场景
- 🔄 **上下文连续性**: 使用 PLANNING.md、TASK.md、CONTEXT.md 跨越 `/clear` 边界
- ⚡ **精简高效**: 13个命令按开发生命周期组织
- 🛡️ **质量保证**: 内置格式化、测试、验证

### 核心哲学

工作流系统设计原则：

1. **维护上下文** - 使用 PLANNING.md、TASK.md、CONTEXT.md 作为持久存储
2. **启用连续性** - 通过 `/wf_03_prime` 跨越 `/clear` 边界继续工作
3. **追踪进度** - 自动更新整个开发周期的任务状态
4. **强制标准** - 应用一致的模式和质量门控
5. **闭合循环** - 每个命令与其他命令集成形成完整工作流
6. **减少冗余** - 将类似功能合并到统一命令中

### 命令格式和约定

所有命令遵循 `/wf_<number>_<name> <ARGUMENTS>` 格式（Slash Commands）：

- **编号前缀** (1-12, 99): 表示工作流中的典型使用顺序
- **命令名称**: 描述性的操作名称
- **参数**: 指定操作范围（功能、组件、错误等）
- **多智能体协调**: 复杂任务使用专门的角色
- **渐进式开发**: 逐步构建并在每个步骤验证

---

## 命令完整参考

> 💡 **说明**: 以下是命令概览，详细执行步骤在各 slash command 文件中

### 第一阶段: 基础设施 (命令 1-3)

| 命令 | 用途 | 何时调用 |
|------|------|---------|
| `/wf_01_planning` | 创建 PLANNING.md (架构/技术栈/标准) | 项目启动、重大规划 |
| `/wf_02_task` | 更新 TASK.md 任务状态和进度 | 任何时刻更新任务 |
| `/wf_03_prime` ⭐ | 加载所有项目上下文 (PRD/PLANNING/TASK/CONTEXT) | **会话开始必须** |

**关键**: `/wf_03_prime` 是会话开始的第一个动作

### 第二阶段: 开发实现 (命令 4-6)

| 命令 | 用途 | 何时调用 |
|------|------|---------|
| `/wf_04_ask` | 架构咨询和设计指导 (支持 `--review-codebase`) | 需要设计建议时 |
| `/wf_05_code` | 多智能体协调开发 (自动格式化/标准遵守) | 实现新功能 |
| `/wf_06_debug` | 系统调试和错误修复 (根本原因分析) | 修复 Bug |

### 第三阶段: 质量保证 (命令 7-10)

| 命令 | 用途 | 何时调用 |
|------|------|---------|
| `/wf_07_test` | 测试开发和执行 (支持 `--coverage`) | 添加测试、验证功能 |
| `/wf_08_review` | 代码审查和质量检查 | 提交前审查 |
| `/wf_09_refactor` | 代码重构和结构改进 | 改进代码质量 |
| `/wf_10_optimize` | 性能优化和瓶颈识别 | 性能改进 |

### 第四阶段: 运维部署 (命令 11-12)

| 命令 | 用途 | 何时调用 |
|------|------|---------|
| `/wf_11_commit` | Git 提交 + 自动更新 CONTEXT.md | 完成工作、保存进度 |
| `/wf_12_deploy_check` | 部署就绪性验证 | 部署前检查 |

### 支持命令 (命令 99)

| 命令 | 用途 | 何时调用 |
|------|------|---------|
| `/wf_99_help` | 完整帮助系统 | 任何时候需要帮助 |

**调用格式**: `/wf_XX_name "参数"` (详细步骤由命令文件处理)

---

## 快速开始指南

### 新用户核心 4 命令 (80% 场景)

这 4 个命令处理大多数开发场景，学习曲线最短：

#### 1️⃣ 项目启动
```bash
/wf_01_planning "项目描述"
```
- **作用**: 创建技术规划文档
- **输出**: PLANNING.md（架构、标准、技术栈）
- **何时用**: 项目开始、重大功能规划

#### 2️⃣ 会话恢复 ⭐ 关键
```bash
/wf_03_prime
```
- **作用**: 加载所有项目上下文
- **何时用**: 会话开始、`/clear` 之后
- **提示**: 每次会话第一个动作

#### 3️⃣ 代码实现
```bash
/wf_05_code "功能描述"
```
- **作用**: 多智能体协调开发
- **特点**: 自动格式化、标准遵守、PRD 对齐
- **何时用**: 实现新功能

#### 4️⃣ 保存进度
```bash
/wf_11_commit "提交信息"
```
- **作用**: Git 提交 + 自动更新 CONTEXT.md
- **特点**: 质量门控、自动格式化
- **何时用**: 完成工作、准备 `/clear`

### 进阶 5 命令 (额外 15% 场景)

掌握基础后学习这些：

| 命令 | 作用 | 何时用 |
|------|------|--------|
| `/wf_02_task update` | 更新任务进度 | 任何时刻 |
| `/wf_04_ask` | 架构咨询 | 需要设计建议 |
| `/wf_06_debug` | 错误修复 | 有 Bug |
| `/wf_07_test` | 测试开发 | 编写测试 |
| `/wf_08_review` | 代码审查 | 提交前 |

### 高级命令

准备好后，探索这些：
- `/wf_09_refactor` - 代码改进
- `/wf_10_optimize` - 性能优化
- `/wf_12_deploy_check` - 部署检查

---

## 工作流决策树

### 我应该用哪个命令？

**从这里开始** → 我想做什么？

```
🆕 全新开始?
├── 📋 新项目启动 → /wf_01_planning "项目描述"
└── 🔄 恢复工作 → /wf_03_prime

💻 开发功能?
├── 🤔 需要设计建议 → /wf_04_ask "技术问题"
├── 💻 写代码实现 → /wf_05_code "功能描述"
├── 🐛 修复 Bug → /wf_06_debug "错误描述"
└── 🧪 添加测试 → /wf_07_test "组件名称"

🔍 提升代码质量?
├── 👀 审查代码 → /wf_08_review
├── 🔧 重构代码 → /wf_09_refactor "要改进的组件"
└── ⚡ 性能优化 → /wf_10_optimize "性能目标"

💾 完成工作?
├── 📝 更新任务 → /wf_02_task update "任务描述"
├── 💾 提交更改 → /wf_11_commit "提交信息"
└── 🚀 部署检查 → /wf_12_deploy_check

❓ 需要帮助? → /wf_99_help
```

### 常见场景工作流

| 场景 | 命令流程 | 说明 |
|------|---------|------|
| 🆕 **全新项目** | `/wf_01_planning` → `/wf_03_prime` → `/wf_05_code` → `/wf_11_commit` | 从零开始建立项目 |
| 📱 **打开会话** | `/wf_03_prime` | 立即加载所有上下文 |
| ✨ **实现功能** | `/wf_04_ask` → `/wf_05_code` → `/wf_07_test` → `/wf_11_commit` | 完整的功能开发流程 |
| 🐛 **修复 Bug** | `/wf_06_debug` → `/wf_07_test` → `/wf_11_commit` | 快速问题解决 |
| 📊 **质量改进** | `/wf_08_review` → `/wf_09_refactor` → `/wf_07_test` → `/wf_11_commit` | 系统性代码改进 |

**💡 小贴士**: 所有命令使用 `/wf_XX` 格式调用，详细步骤由 slash command 文件处理

---

## 完整工作流模式

### 📱 会话管理生命周期

上下文连续性的关键流程：

```
会话开始  → /wf_03_prime (加载所有上下文)
  ↓
主动工作  → /wf_05_code, /wf_07_test 等
  ↓
保存进度  → /wf_11_commit (自动更新 CONTEXT.md)
  ↓
清理上下文 → /clear (当上下文过大时)
  ↓
恢复工作  → /wf_03_prime (重新加载并继续)
```

**最佳实践**:
- 始终以 `/wf_03_prime` 开始会话
- 定期用 `/wf_11_commit` 保存进度
- 工作前检查 TASK.md 当前状态

### ✨ 功能开发完整流程

从概念到部署的完整生命周期：

```
1. 设计规划  → /wf_04_ask "架构建议"
2. 代码实现  → /wf_05_code "功能描述"
3. 编写测试  → /wf_07_test "组件名称"
4. 代码审查  → /wf_08_review
5. 提交代码  → /wf_11_commit "功能完成"
6. 更新任务  → /wf_02_task update "任务状态"
```

**预计时间**: 中等功能 30-60 分钟

### 🐛 Bug 修复快速路径

高效的问题解决流程：

```
1. 错误分析  → /wf_06_debug "错误描述"
2. 验证修复  → /wf_07_test "受影响组件"
3. 提交修复  → /wf_11_commit "修复已应用"
```

**预计时间**: 简单 Bug 5-15 分钟，复杂 Bug 30+ 分钟

### 📊 代码质量改进流程

系统性的代码改进：

```
1. 质量分析  → /wf_08_review
2. 代码重构  → /wf_09_refactor "要改进的组件"
3. 性能优化  → /wf_10_optimize "性能目标"
4. 回归测试  → /wf_07_test --coverage (确保无回归)
5. 提交改进  → /wf_11_commit "质量改进"
```

**预计时间**: 取决于改进范围，通常 45-120 分钟

---

## 核心文件说明

这些文件形成闭环工作流的基础。所有文件应在 `docs/management/` 目录下维护。

### 📋 PRD.md - 项目需求文档

**特性**: 只读参考，权威数据源

**包含内容**:
- 官方项目需求和规范
- 业务目标和成功标准
- 利益相关者需求和约束
- 性能、安全、可用性要求

**维护规则**:
- ✅ 只读参考：所有命令必须尊重其需求
- ❌ 不自动修改：只有授权人员可修改
- 📌 质量保证：所有决策必须对齐 PRD
- 🔗 可追溯性：TASK.md 映射到 PRD 需求

### 🏗️ PLANNING.md - 技术规划和架构

**特性**: 技术蓝图，与 PRD.md 对齐

**包含内容**:
- 项目概述和目标（源自 PRD.md）
- 系统架构和设计（满足 PRD 需求）
- 技术栈和工具选择
- 开发标准和模式
- 测试和部署策略
- PRD 合规清单

**维护规则**:
- 📝 定期更新：重要决策后立即记录
- 📍 决策跟踪：记录"为什么"选择某技术
- 🔄 与 PRD 同步：检查是否满足所有需求

### ✅ TASK.md - 任务追踪

**特性**: 动态进度管理

**包含内容**:
- 分类任务列表（映射到 PRD）
- 任务状态和进度
- 依赖和阻挡因素
- 完成历史记录
- PRD 可追溯性

**维护规则**:
- 🔄 实时更新：完成工作后立即更新
- 📊 进度可见：清晰显示完成百分比
- 🔗 需求追踪：每项任务关联 PRD 需求

### 📱 CONTEXT.md - 会话上下文

**特性**: 自动管理，支持会话连续性

**包含内容**:
- 最近会话完成的工作
- 关键决策（带 PRD 对齐注释）
- 当前关注点
- 下一个优先项
- 自动更新时间戳

**维护规则**:
- 🤖 自动更新：由 /wf_11_commit 自动管理
- ⏰ 时间戳：记录工作时间点
- 📋 快照：保存工作的"相机快照"

### 📚 KNOWLEDGE.md - 知识库

**特性**: 团队积累的经验和决策

**包含内容**:
- 架构决策记录（ADR）
- 常见问题和解决方案
- 可重用代码模式
- 项目特定的最佳实践
- 技术研究和调查结果

**维护规则**:
- 📖 文献库：长期知识存储
- 🔍 可搜索：易于查找过去的决策
- 🧠 集体智慧：记录团队学到的东西

---

## 开发标准

### 集成规则

所有命令必须遵循这些规则以保持系统的连贯性：

| 规则 | 说明 | 实施方式 |
|------|------|---------|
| **PRD 对齐** | 所有命令必须参考 PRD.md 需求 | 每个决策检查 PRD |
| **上下文加载** | 每个命令读取 PLANNING.md、TASK.md、CONTEXT.md | 命令启动时自动加载 |
| **进度追踪** | 工作完成后更新 TASK.md | 包含 PRD 可追溯性 |
| **标准遵守** | 代码遵循 PLANNING.md 指南 | 自动格式化和 lint |
| **决策记录** | 重要决策更新 PLANNING.md | 包含"为什么"和 PRD 对齐 |
| **会话连续性** | CONTEXT.md 由 /wf_11_commit 自动更新 | 支持 /wf_03_prime 加载 |

### 多智能体协调

工作流命令系统使用多智能体方法，每个命令可以协调相关的专家：

| 智能体 | 职责 | 关键技能 |
|--------|------|---------|
| **Architect 架构师** | 高级设计和结构分析 | 系统设计、模式、权衡 |
| **Implementation Engineer 实现工程师** | 遵循标准的核心功能开发 | 代码编写、最佳实践 |
| **Integration Specialist 集成专家** | 系统兼容性和依赖管理 | 系统集成、依赖、接口 |
| **Code Reviewer 审查员** | 质量验证和标准检查 | 代码质量、安全、性能 |
| **Test Specialist 测试专家** | 单元、集成、覆盖率测试 | 测试策略、覆盖率分析 |
| **Structure Analyst 结构分析师** | 代码架构评估和改进 | 重构、设计模式 |
| **Debug Coordinator 调试协调员** | 系统错误分析和解决 | 错误诊断、根本原因分析 |
| **Performance Optimizer 性能优化师** | 系统性能改进 | 性能分析、瓶颈识别 |

### 代码质量

**基本原则**:
- 📚 遵循现有代码模式
- ✅ 维护测试覆盖率要求
- 🎨 自动格式化（Python: black, JS/TS: prettier, C++: clang-format, Go: gofmt）
- 🚫 零容忍尾部空格（所有文件）
- 📝 统一 Unix 行结尾（LF）
- 📖 记录重要变更

### 质量门控 Pre-commit

**自动化框架**: 使用 pre-commit 钩子进行自动质量验证

**一次性安装**:
```bash
pip install pre-commit
pre-commit install
```

**自动检查** (提交时自动运行):
- ✓ 尾部空格检测（零容忍）
- ✓ 文件格式验证
- ✓ 行结尾验证（Unix LF）
- ✓ Markdown 链接验证
- ✓ 命令参考一致性

**手动验证** (如需要):
```bash
pre-commit run --all-files    # 检查所有文件
pre-commit run                 # 检查暂存文件
```

### Git 提交工作流

**提交信息格式**:
```
[type][scope] subject

body
```

| 类型 | 说明 | 例子 |
|------|------|------|
| `[feat]` | 新功能 | `[feat] Add user authentication` |
| `[fix]` | Bug 修复 | `[fix] 修复登录超时问题` |
| `[docs]` | 文档更新 | `[docs] 更新 API 文档` |
| `[refactor]` | 代码重构 | `[refactor] 优化数据库查询` |
| `[test]` | 测试添加 | `[test] Add user service tests` |

**最佳实践**:
- 始终运行 pre-commit 检查
- 将逻辑上不同的变更分为不同提交
- 包含任务引用: `Task: #123`
- /wf_11_commit 自动处理格式化和 CONTEXT.md 更新

### 测试策略

- ✍️ 为新功能编写测试
- 📊 维护覆盖率目标（使用 `/wf_07_test --coverage`）
- 🧪 部署前测试
- 📋 在 PLANNING.md 中记录测试策略

### 错误调试流程

系统方法（遵循 /wf_06_debug）:

1. **分析** - 详细分类错误输出
2. **研究** - 使用可用工具（context7 MCP、搜索等）
3. **实现** - 针对性地修复根本原因
4. **验证** - 重新运行原始命令确认修复
5. **迭代** - 如有新错误继续处理
6. **文档** - 将解决方案记录到 KNOWLEDGE.md

---

## 最佳实践 & 故障排除

### 最佳实践清单

| 实践 | 说明 | 何时做 |
|------|------|--------|
| 🔄 **会话开始** | 运行 `/wf_03_prime` 加载上下文 | 每个新会话开始 |
| 📝 **定期更新** | 保持 TASK.md 最新进度 | 完成任务后立即 |
| 📖 **记录决策** | 更新 PLANNING.md 架构变更 | 重要决策后 |
| 🧪 **连续测试** | 变更后运行测试 | 重大改动后 |
| 👀 **审查前提交** | 使用 `/wf_08_review` | 提交之前 |
| 🎯 **质量第一** | 运行 pre-commit 检查 | 提交前 |
| ✅ **完全委托提交** | 让 /wf_11_commit 处理一切 | 准备提交时 |

### 常见问题排查

**问题**: 丢失项目上下文
```bash
解决方案:
1. /wf_03_prime            # 从核心文件重新加载
2. 检查 CONTEXT.md         # 查看最新会话状态
3. 检查 PLANNING.md        # 回顾架构
4. 检查 TASK.md           # 查看当前任务
```

**问题**: 不清楚需求
```bash
解决方案:
1. /wf_04_ask "问题"        # 获取架构咨询
2. 更新 PLANNING.md         # 记录决策
3. 创建 TASK.md 任务        # 明确行动项
```

**问题**: 代码质量问题
```bash
解决方案:
1. /wf_08_review           # 进行代码审查
2. /wf_09_refactor         # 进行代码改进
3. /wf_07_test --coverage  # 验证覆盖率
```

**问题**: 尾部空格被检测
```bash
自动修复:
pre-commit run --all-files   # 自动识别和修复
```

**问题**: 提交被质量门控拒绝
```bash
调查和修复:
1. pre-commit run           # 查看具体问题
2. 手动修复或使用自动修复
3. 重新尝试提交
```

**问题**: 行结尾混乱
```bash
解决方案:
# Pre-commit 钩子自动检测和拒绝不一致的行结尾
# 使用 pre-commit run 自动修复
pre-commit run --all-files
```

**问题**: Pre-commit 未安装
```bash
安装:
pip install pre-commit
pre-commit install
pre-commit run --all-files
```

### 时间点管理规范

**核心原则**: 绝不手动输入日期，总是使用命令动态获取

#### 标准时间获取命令
```bash
# 基础日期格式
TODAY=$(date +%Y-%m-%d)              # 今天: 2025-08-21
YESTERDAY=$(date -d 'yesterday' +%Y-%m-%d)  # 昨天: 2025-08-20
TIMESTAMP=$(date +%Y-%m-%d\ %H:%M:%S)       # 完整时间戳

# 中文格式（用于文档）
TODAY_CN=$(date +%Y年%m月%d日)        # 2025年08月21日
WEEK_CN=$(date +%Y年第%U周)           # 2025年第34周
```

#### 日期类型与使用规则
1. **历史日期** (创建时间、发布日期)
   - 创建时使用: `$(date +%Y-%m-%d)`
   - 一旦确定，永不修改

2. **维护日期** (最后更新、修改时间)
   - 总是使用: `$(date +%Y-%m-%d)`
   - 每次修改时自动更新

3. **ADR决策日期** (架构决策记录)
   - 决策当天: `$(date +%Y-%m-%d)`
   - 体现决策制定的具体时间

#### 文档模板示例
```markdown
**创建日期**: $(date +%Y-%m-%d)      # 项目启动时固定
**最后更新**: $(date +%Y-%m-%d)      # 每次编辑自动更新
**版本发布**: $(date +%Y-%m-%d)      # 版本发布时固定
**决策日期**: $(date +%Y-%m-%d)      # ADR决策时固定
```

#### 预防时间错误的强制规则
- ❌ **禁止**: 手动输入任何形式的日期
- ✅ **必须**: 使用bash命令获取当前时间
- ✅ **必须**: 在 /wf_11_commit 中验证日期正确性
- ✅ **必须**: 区分历史日期和维护日期的处理方式

---

## 快速参考

**记住这 5 件事**:
1. 🔄 会话开始时运行 `/wf_03_prime`
2. 💻 使用 `/wf_05_code` 实现功能
3. ✅ 提交前使用 `/wf_08_review`
4. 💾 完成后用 `/wf_11_commit` 保存
5. ❓ 不确定时运行 `/wf_99_help`

**获取帮助**:
- 技术问题: `/wf_04_ask "<问题>"`
- Bug 修复: `/wf_06_debug "<错误>"`
- 质量改进: `/wf_08_review` + `/wf_09_refactor`

该系统确保开发连续性、质量维护和高效的进度追踪，同时保持简洁和避免冗余。
